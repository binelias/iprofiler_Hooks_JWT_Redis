{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Subchannel = void 0;\n\nconst http2 = require(\"http2\");\n\nconst tls_1 = require(\"tls\");\n\nconst connectivity_state_1 = require(\"./connectivity-state\");\n\nconst backoff_timeout_1 = require(\"./backoff-timeout\");\n\nconst resolver_1 = require(\"./resolver\");\n\nconst logging = require(\"./logging\");\n\nconst constants_1 = require(\"./constants\");\n\nconst http_proxy_1 = require(\"./http_proxy\");\n\nconst net = require(\"net\");\n\nconst uri_parser_1 = require(\"./uri-parser\");\n\nconst subchannel_address_1 = require(\"./subchannel-address\");\n\nconst channelz_1 = require(\"./channelz\");\n\nconst clientVersion = require('../../package.json').version;\n\nconst TRACER_NAME = 'subchannel';\nconst FLOW_CONTROL_TRACER_NAME = 'subchannel_flowctrl';\nconst MIN_CONNECT_TIMEOUT_MS = 20000;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\n\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst {\n  HTTP2_HEADER_AUTHORITY,\n  HTTP2_HEADER_CONTENT_TYPE,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_TE,\n  HTTP2_HEADER_USER_AGENT\n} = http2.constants;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\n\nfunction uniformRandom(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\nconst tooManyPingsData = Buffer.from('too_many_pings', 'ascii');\n\nclass Subchannel {\n  /**\n   * A class representing a connection to a single backend.\n   * @param channelTarget The target string for the channel as a whole\n   * @param subchannelAddress The address for the backend that this subchannel\n   *     will connect to\n   * @param options The channel options, plus any specific subchannel options\n   *     for this subchannel\n   * @param credentials The channel credentials used to establish this\n   *     connection\n   */\n  constructor(channelTarget, subchannelAddress, options, credentials) {\n    this.channelTarget = channelTarget;\n    this.subchannelAddress = subchannelAddress;\n    this.options = options;\n    this.credentials = credentials;\n    /**\n     * The subchannel's current connectivity state. Invariant: `session` === `null`\n     * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n     */\n\n    this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n    /**\n     * The underlying http2 session used to make requests.\n     */\n\n    this.session = null;\n    /**\n     * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n     * CONNECTING instead of IDLE when the backoff timeout ends.\n     */\n\n    this.continueConnecting = false;\n    /**\n     * A list of listener functions that will be called whenever the connectivity\n     * state changes. Will be modified by `addConnectivityStateListener` and\n     * `removeConnectivityStateListener`\n     */\n\n    this.stateListeners = [];\n    /**\n     * A list of listener functions that will be called when the underlying\n     * socket disconnects. Used for ending active calls with an UNAVAILABLE\n     * status.\n     */\n\n    this.disconnectListeners = [];\n    /**\n     * The amount of time in between sending pings\n     */\n\n    this.keepaliveTimeMs = KEEPALIVE_MAX_TIME_MS;\n    /**\n     * The amount of time to wait for an acknowledgement after sending a ping\n     */\n\n    this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\n    /**\n     * Indicates whether keepalive pings should be sent without any active calls\n     */\n\n    this.keepaliveWithoutCalls = false;\n    /**\n     * Tracks calls with references to this subchannel\n     */\n\n    this.callRefcount = 0;\n    /**\n     * Tracks channels and subchannel pools with references to this subchannel\n     */\n\n    this.refcount = 0; // Channelz info\n\n    this.channelzEnabled = true;\n    this.callTracker = new channelz_1.ChannelzCallTracker();\n    this.childrenTracker = new channelz_1.ChannelzChildrenTracker(); // Channelz socket info\n\n    this.channelzSocketRef = null;\n    /**\n     * Name of the remote server, if it is not the same as the subchannel\n     * address, i.e. if connecting through an HTTP CONNECT proxy.\n     */\n\n    this.remoteName = null;\n    this.streamTracker = new channelz_1.ChannelzCallTracker();\n    this.keepalivesSent = 0;\n    this.messagesSent = 0;\n    this.messagesReceived = 0;\n    this.lastMessageSentTimestamp = null;\n    this.lastMessageReceivedTimestamp = null; // Build user-agent string.\n\n    this.userAgent = [options['grpc.primary_user_agent'], `grpc-node-js/${clientVersion}`, options['grpc.secondary_user_agent']].filter(e => e).join(' '); // remove falsey values first\n\n    if ('grpc.keepalive_time_ms' in options) {\n      this.keepaliveTimeMs = options['grpc.keepalive_time_ms'];\n    }\n\n    if ('grpc.keepalive_timeout_ms' in options) {\n      this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms'];\n    }\n\n    if ('grpc.keepalive_permit_without_calls' in options) {\n      this.keepaliveWithoutCalls = options['grpc.keepalive_permit_without_calls'] === 1;\n    } else {\n      this.keepaliveWithoutCalls = false;\n    }\n\n    this.keepaliveIntervalId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveIntervalId);\n    this.keepaliveTimeoutId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveTimeoutId);\n    const backoffOptions = {\n      initialDelay: options['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: options['grpc.max_reconnect_backoff_ms']\n    };\n    this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n      this.handleBackoffTimer();\n    }, backoffOptions);\n    this.subchannelAddressString = subchannel_address_1.subchannelAddressToString(subchannelAddress);\n\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n\n    this.channelzTrace = new channelz_1.ChannelzTrace();\n    this.channelzRef = channelz_1.registerChannelzSubchannel(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\n\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');\n    }\n\n    this.trace('Subchannel constructed with options ' + JSON.stringify(options, undefined, 2));\n  }\n\n  getChannelzInfo() {\n    return {\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists(),\n      target: this.subchannelAddressString\n    };\n  }\n\n  getChannelzSocketInfo() {\n    var _a, _b, _c;\n\n    if (this.session === null) {\n      return null;\n    }\n\n    const sessionSocket = this.session.socket;\n    const remoteAddress = sessionSocket.remoteAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n    const localAddress = sessionSocket.localAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.localAddress, sessionSocket.localPort) : null;\n    let tlsInfo;\n\n    if (this.session.encrypted) {\n      const tlsSocket = sessionSocket;\n      const cipherInfo = tlsSocket.getCipher();\n      const certificate = tlsSocket.getCertificate();\n      const peerCertificate = tlsSocket.getPeerCertificate();\n      tlsInfo = {\n        cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n        localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,\n        remoteCertificate: peerCertificate && 'raw' in peerCertificate ? peerCertificate.raw : null\n      };\n    } else {\n      tlsInfo = null;\n    }\n\n    const socketInfo = {\n      remoteAddress: remoteAddress,\n      localAddress: localAddress,\n      security: tlsInfo,\n      remoteName: this.remoteName,\n      streamsStarted: this.streamTracker.callsStarted,\n      streamsSucceeded: this.streamTracker.callsSucceeded,\n      streamsFailed: this.streamTracker.callsFailed,\n      messagesSent: this.messagesSent,\n      messagesReceived: this.messagesReceived,\n      keepAlivesSent: this.keepalivesSent,\n      lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\n      lastRemoteStreamCreatedTimestamp: null,\n      lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n      lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n      localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n      remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n    };\n    return socketInfo;\n  }\n\n  resetChannelzSocketInfo() {\n    if (!this.channelzEnabled) {\n      return;\n    }\n\n    if (this.channelzSocketRef) {\n      channelz_1.unregisterChannelzRef(this.channelzSocketRef);\n      this.childrenTracker.unrefChild(this.channelzSocketRef);\n      this.channelzSocketRef = null;\n    }\n\n    this.remoteName = null;\n    this.streamTracker = new channelz_1.ChannelzCallTracker();\n    this.keepalivesSent = 0;\n    this.messagesSent = 0;\n    this.messagesReceived = 0;\n    this.lastMessageSentTimestamp = null;\n    this.lastMessageReceivedTimestamp = null;\n  }\n\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  refTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_refcount', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  flowControlTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  internalsTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_internals', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  keepaliveTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  handleBackoffTimer() {\n    if (this.continueConnecting) {\n      this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n    } else {\n      this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.IDLE);\n    }\n  }\n  /**\n   * Start a backoff timer with the current nextBackoff timeout\n   */\n\n\n  startBackoff() {\n    this.backoffTimeout.runOnce();\n  }\n\n  stopBackoff() {\n    this.backoffTimeout.stop();\n    this.backoffTimeout.reset();\n  }\n\n  sendPing() {\n    var _a, _b;\n\n    if (this.channelzEnabled) {\n      this.keepalivesSent += 1;\n    }\n\n    this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\n    this.keepaliveTimeoutId = setTimeout(() => {\n      this.keepaliveTrace('Ping timeout passed without response');\n      this.handleDisconnect();\n    }, this.keepaliveTimeoutMs);\n    (_b = (_a = this.keepaliveTimeoutId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    this.session.ping((err, duration, payload) => {\n      this.keepaliveTrace('Received ping response');\n      clearTimeout(this.keepaliveTimeoutId);\n    });\n  }\n\n  startKeepalivePings() {\n    var _a, _b;\n\n    this.keepaliveIntervalId = setInterval(() => {\n      this.sendPing();\n    }, this.keepaliveTimeMs);\n    (_b = (_a = this.keepaliveIntervalId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    /* Don't send a ping immediately because whatever caused us to start\n     * sending pings should also involve some network activity. */\n  }\n  /**\n   * Stop keepalive pings when terminating a connection. This discards the\n   * outstanding ping timeout, so it should not be called if the same\n   * connection will still be used.\n   */\n\n\n  stopKeepalivePings() {\n    clearInterval(this.keepaliveIntervalId);\n    clearTimeout(this.keepaliveTimeoutId);\n  }\n\n  createSession(proxyConnectionResult) {\n    var _a, _b, _c;\n\n    if (proxyConnectionResult.realTarget) {\n      this.remoteName = uri_parser_1.uriToString(proxyConnectionResult.realTarget);\n      this.trace('creating HTTP/2 session through proxy to ' + proxyConnectionResult.realTarget);\n    } else {\n      this.remoteName = null;\n      this.trace('creating HTTP/2 session');\n    }\n\n    const targetAuthority = resolver_1.getDefaultAuthority((_a = proxyConnectionResult.realTarget) !== null && _a !== void 0 ? _a : this.channelTarget);\n    let connectionOptions = this.credentials._getConnectionOptions() || {};\n    connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;\n\n    if ('grpc-node.max_session_memory' in this.options) {\n      connectionOptions.maxSessionMemory = this.options['grpc-node.max_session_memory'];\n    } else {\n      /* By default, set a very large max session memory limit, to effectively\n       * disable enforcement of the limit. Some testing indicates that Node's\n       * behavior degrades badly when this limit is reached, so we solve that\n       * by disabling the check entirely. */\n      connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n    }\n\n    let addressScheme = 'http://';\n\n    if ('secureContext' in connectionOptions) {\n      addressScheme = 'https://'; // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n\n      if (this.options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = this.options['grpc.ssl_target_name_override'];\n\n        connectionOptions.checkServerIdentity = (host, cert) => {\n          return tls_1.checkServerIdentity(sslTargetNameOverride, cert);\n        };\n\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        const authorityHostname = (_c = (_b = uri_parser_1.splitHostPort(targetAuthority)) === null || _b === void 0 ? void 0 : _b.host) !== null && _c !== void 0 ? _c : 'localhost'; // We want to always set servername to support SNI\n\n        connectionOptions.servername = authorityHostname;\n      }\n\n      if (proxyConnectionResult.socket) {\n        /* This is part of the workaround for\n         * https://github.com/nodejs/node/issues/32922. Without that bug,\n         * proxyConnectionResult.socket would always be a plaintext socket and\n         * this would say\n         * connectionOptions.socket = proxyConnectionResult.socket; */\n        connectionOptions.createConnection = (authority, option) => {\n          return proxyConnectionResult.socket;\n        };\n      }\n    } else {\n      /* In all but the most recent versions of Node, http2.connect does not use\n       * the options when establishing plaintext connections, so we need to\n       * establish that connection explicitly. */\n      connectionOptions.createConnection = (authority, option) => {\n        if (proxyConnectionResult.socket) {\n          return proxyConnectionResult.socket;\n        } else {\n          /* net.NetConnectOpts is declared in a way that is more restrictive\n           * than what net.connect will actually accept, so we use the type\n           * assertion to work around that. */\n          return net.connect(this.subchannelAddress);\n        }\n      };\n    }\n\n    connectionOptions = Object.assign(Object.assign({}, connectionOptions), this.subchannelAddress);\n    /* http2.connect uses the options here:\n     * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n     * The spread operator overides earlier values with later ones, so any port\n     * or host values in the options will be used rather than any values extracted\n     * from the first argument. In addition, the path overrides the host and port,\n     * as documented for plaintext connections here:\n     * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n     * and for TLS connections here:\n     * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n     * earlier versions of Node, http2.connect passes these options to\n     * tls.connect but not net.connect, so in the insecure case we still need\n     * to set the createConnection option above to create the connection\n     * explicitly. We cannot do that in the TLS case because http2.connect\n     * passes necessary additional options to tls.connect.\n     * The first argument just needs to be parseable as a URL and the scheme\n     * determines whether the connection will be established over TLS or not.\n     */\n\n    const session = http2.connect(addressScheme + targetAuthority, connectionOptions);\n    this.session = session;\n    this.channelzSocketRef = channelz_1.registerChannelzSocket(this.subchannelAddressString, () => this.getChannelzSocketInfo(), this.channelzEnabled);\n\n    if (this.channelzEnabled) {\n      this.childrenTracker.refChild(this.channelzSocketRef);\n    }\n\n    session.unref();\n    /* For all of these events, check if the session at the time of the event\n     * is the same one currently attached to this subchannel, to ensure that\n     * old events from previous connection attempts cannot cause invalid state\n     * transitions. */\n\n    session.once('connect', () => {\n      if (this.session === session) {\n        this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.READY);\n      }\n    });\n    session.once('close', () => {\n      if (this.session === session) {\n        this.trace('connection closed');\n        this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n        /* Transitioning directly to IDLE here should be OK because we are not\n         * doing any backoff, because a connection was established at some\n         * point */\n\n        this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n      }\n    });\n    session.once('goaway', (errorCode, lastStreamID, opaqueData) => {\n      if (this.session === session) {\n        /* See the last paragraph of\n         * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n        if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM && opaqueData.equals(tooManyPingsData)) {\n          this.keepaliveTimeMs = Math.min(2 * this.keepaliveTimeMs, KEEPALIVE_MAX_TIME_MS);\n          logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${uri_parser_1.uriToString(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTimeMs} ms`);\n        }\n\n        this.trace('connection closed by GOAWAY with code ' + errorCode);\n        this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n      }\n    });\n    session.once('error', error => {\n      /* Do nothing here. Any error should also trigger a close event, which is\n       * where we want to handle that.  */\n      this.trace('connection closed with error ' + error.message);\n    });\n\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      session.on('remoteSettings', settings => {\n        this.trace('new settings received' + (this.session !== session ? ' on the old connection' : '') + ': ' + JSON.stringify(settings));\n      });\n      session.on('localSettings', settings => {\n        this.trace('local settings acknowledged by remote' + (this.session !== session ? ' on the old connection' : '') + ': ' + JSON.stringify(settings));\n      });\n    }\n  }\n\n  startConnectingInternal() {\n    var _a, _b;\n    /* Pass connection options through to the proxy so that it's able to\n     * upgrade it's connection to support tls if needed.\n     * This is a workaround for https://github.com/nodejs/node/issues/32922\n     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n\n\n    const connectionOptions = this.credentials._getConnectionOptions() || {};\n\n    if ('secureContext' in connectionOptions) {\n      connectionOptions.ALPNProtocols = ['h2']; // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n\n      if (this.options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = this.options['grpc.ssl_target_name_override'];\n\n        connectionOptions.checkServerIdentity = (host, cert) => {\n          return tls_1.checkServerIdentity(sslTargetNameOverride, cert);\n        };\n\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        if ('grpc.http_connect_target' in this.options) {\n          /* This is more or less how servername will be set in createSession\n           * if a connection is successfully established through the proxy.\n           * If the proxy is not used, these connectionOptions are discarded\n           * anyway */\n          const targetPath = resolver_1.getDefaultAuthority((_a = uri_parser_1.parseUri(this.options['grpc.http_connect_target'])) !== null && _a !== void 0 ? _a : {\n            path: 'localhost'\n          });\n          const hostPort = uri_parser_1.splitHostPort(targetPath);\n          connectionOptions.servername = (_b = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _b !== void 0 ? _b : targetPath;\n        }\n      }\n    }\n\n    http_proxy_1.getProxiedConnection(this.subchannelAddress, this.options, connectionOptions).then(result => {\n      this.createSession(result);\n    }, reason => {\n      this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n    });\n  }\n\n  handleDisconnect() {\n    this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n\n    for (const listener of this.disconnectListeners) {\n      listener();\n    }\n  }\n  /**\n   * Initiate a state transition from any element of oldStates to the new\n   * state. If the current connectivityState is not in oldStates, do nothing.\n   * @param oldStates The set of states to transition from\n   * @param newState The state to transition to\n   * @returns True if the state changed, false otherwise\n   */\n\n\n  transitionToState(oldStates, newState) {\n    if (oldStates.indexOf(this.connectivityState) === -1) {\n      return false;\n    }\n\n    this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    }\n\n    const previousState = this.connectivityState;\n    this.connectivityState = newState;\n\n    switch (newState) {\n      case connectivity_state_1.ConnectivityState.READY:\n        this.stopBackoff();\n        const session = this.session;\n        session.socket.once('close', () => {\n          if (this.session === session) {\n            this.handleDisconnect();\n          }\n        });\n\n        if (this.keepaliveWithoutCalls) {\n          this.startKeepalivePings();\n        }\n\n        break;\n\n      case connectivity_state_1.ConnectivityState.CONNECTING:\n        this.startBackoff();\n        this.startConnectingInternal();\n        this.continueConnecting = false;\n        break;\n\n      case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n        if (this.session) {\n          this.session.close();\n        }\n\n        this.session = null;\n        this.resetChannelzSocketInfo();\n        this.stopKeepalivePings();\n        /* If the backoff timer has already ended by the time we get to the\n         * TRANSIENT_FAILURE state, we want to immediately transition out of\n         * TRANSIENT_FAILURE as though the backoff timer is ending right now */\n\n        if (!this.backoffTimeout.isRunning()) {\n          process.nextTick(() => {\n            this.handleBackoffTimer();\n          });\n        }\n\n        break;\n\n      case connectivity_state_1.ConnectivityState.IDLE:\n        if (this.session) {\n          this.session.close();\n        }\n\n        this.session = null;\n        this.resetChannelzSocketInfo();\n        this.stopKeepalivePings();\n        break;\n\n      default:\n        throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n    }\n    /* We use a shallow copy of the stateListeners array in case a listener\n     * is removed during this iteration */\n\n\n    for (const listener of [...this.stateListeners]) {\n      listener(this, previousState, newState);\n    }\n\n    return true;\n  }\n  /**\n   * Check if the subchannel associated with zero calls and with zero channels.\n   * If so, shut it down.\n   */\n\n\n  checkBothRefcounts() {\n    /* If no calls, channels, or subchannel pools have any more references to\n     * this subchannel, we can be sure it will never be used again. */\n    if (this.callRefcount === 0 && this.refcount === 0) {\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Shutting down');\n      }\n\n      this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n\n      if (this.channelzEnabled) {\n        channelz_1.unregisterChannelzRef(this.channelzRef);\n      }\n    }\n  }\n\n  callRef() {\n    this.refTrace('callRefcount ' + this.callRefcount + ' -> ' + (this.callRefcount + 1));\n\n    if (this.callRefcount === 0) {\n      if (this.session) {\n        this.session.ref();\n      }\n\n      this.backoffTimeout.ref();\n\n      if (!this.keepaliveWithoutCalls) {\n        this.startKeepalivePings();\n      }\n    }\n\n    this.callRefcount += 1;\n  }\n\n  callUnref() {\n    this.refTrace('callRefcount ' + this.callRefcount + ' -> ' + (this.callRefcount - 1));\n    this.callRefcount -= 1;\n\n    if (this.callRefcount === 0) {\n      if (this.session) {\n        this.session.unref();\n      }\n\n      this.backoffTimeout.unref();\n\n      if (!this.keepaliveWithoutCalls) {\n        clearInterval(this.keepaliveIntervalId);\n      }\n\n      this.checkBothRefcounts();\n    }\n  }\n\n  ref() {\n    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount + 1));\n    this.refcount += 1;\n  }\n\n  unref() {\n    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount - 1));\n    this.refcount -= 1;\n    this.checkBothRefcounts();\n  }\n\n  unrefIfOneRef() {\n    if (this.refcount === 1) {\n      this.unref();\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Start a stream on the current session with the given `metadata` as headers\n   * and then attach it to the `callStream`. Must only be called if the\n   * subchannel's current connectivity state is READY.\n   * @param metadata\n   * @param callStream\n   */\n\n\n  startCallStream(metadata, callStream, extraFilters) {\n    const headers = metadata.toHttp2Headers();\n    headers[HTTP2_HEADER_AUTHORITY] = callStream.getHost();\n    headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n    headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n    headers[HTTP2_HEADER_METHOD] = 'POST';\n    headers[HTTP2_HEADER_PATH] = callStream.getMethod();\n    headers[HTTP2_HEADER_TE] = 'trailers';\n    let http2Stream;\n    /* In theory, if an error is thrown by session.request because session has\n     * become unusable (e.g. because it has received a goaway), this subchannel\n     * should soon see the corresponding close or goaway event anyway and leave\n     * READY. But we have seen reports that this does not happen\n     * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n     * so for defense in depth, we just discard the session when we see an\n     * error here.\n     */\n\n    try {\n      http2Stream = this.session.request(headers);\n    } catch (e) {\n      this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n      throw e;\n    }\n\n    let headersString = '';\n\n    for (const header of Object.keys(headers)) {\n      headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n    }\n\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'call_stream', 'Starting stream [' + callStream.getCallNumber() + '] on subchannel ' + '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' with headers\\n' + headersString);\n    this.flowControlTrace('local window size: ' + this.session.state.localWindowSize + ' remote window size: ' + this.session.state.remoteWindowSize);\n    const streamSession = this.session;\n    this.internalsTrace('session.closed=' + streamSession.closed + ' session.destroyed=' + streamSession.destroyed + ' session.socket.destroyed=' + streamSession.socket.destroyed);\n    let statsTracker;\n\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      callStream.addStatusWatcher(status => {\n        if (status.code === constants_1.Status.OK) {\n          this.callTracker.addCallSucceeded();\n        } else {\n          this.callTracker.addCallFailed();\n        }\n      });\n      this.streamTracker.addCallStarted();\n      callStream.addStreamEndWatcher(success => {\n        if (streamSession === this.session) {\n          if (success) {\n            this.streamTracker.addCallSucceeded();\n          } else {\n            this.streamTracker.addCallFailed();\n          }\n        }\n      });\n      statsTracker = {\n        addMessageSent: () => {\n          this.messagesSent += 1;\n          this.lastMessageSentTimestamp = new Date();\n        },\n        addMessageReceived: () => {\n          this.messagesReceived += 1;\n        }\n      };\n    } else {\n      statsTracker = {\n        addMessageSent: () => {},\n        addMessageReceived: () => {}\n      };\n    }\n\n    callStream.attachHttp2Stream(http2Stream, this, extraFilters, statsTracker);\n  }\n  /**\n   * If the subchannel is currently IDLE, start connecting and switch to the\n   * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n   * the next time it would transition to IDLE, start connecting again instead.\n   * Otherwise, do nothing.\n   */\n\n\n  startConnecting() {\n    /* First, try to transition from IDLE to connecting. If that doesn't happen\n     * because the state is not currently IDLE, check if it is\n     * TRANSIENT_FAILURE, and if so indicate that it should go back to\n     * connecting after the backoff timer ends. Otherwise do nothing */\n    if (!this.transitionToState([connectivity_state_1.ConnectivityState.IDLE], connectivity_state_1.ConnectivityState.CONNECTING)) {\n      if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n        this.continueConnecting = true;\n      }\n    }\n  }\n  /**\n   * Get the subchannel's current connectivity state.\n   */\n\n\n  getConnectivityState() {\n    return this.connectivityState;\n  }\n  /**\n   * Add a listener function to be called whenever the subchannel's\n   * connectivity state changes.\n   * @param listener\n   */\n\n\n  addConnectivityStateListener(listener) {\n    this.stateListeners.push(listener);\n  }\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n\n\n  removeConnectivityStateListener(listener) {\n    const listenerIndex = this.stateListeners.indexOf(listener);\n\n    if (listenerIndex > -1) {\n      this.stateListeners.splice(listenerIndex, 1);\n    }\n  }\n\n  addDisconnectListener(listener) {\n    this.disconnectListeners.push(listener);\n  }\n\n  removeDisconnectListener(listener) {\n    const listenerIndex = this.disconnectListeners.indexOf(listener);\n\n    if (listenerIndex > -1) {\n      this.disconnectListeners.splice(listenerIndex, 1);\n    }\n  }\n  /**\n   * Reset the backoff timeout, and immediately start connecting if in backoff.\n   */\n\n\n  resetBackoff() {\n    this.backoffTimeout.reset();\n    this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n  }\n\n  getAddress() {\n    return this.subchannelAddressString;\n  }\n\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n\n  getRealSubchannel() {\n    return this;\n  }\n\n}\n\nexports.Subchannel = Subchannel;","map":{"version":3,"mappings":"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","names":["clientVersion","require","version","TRACER_NAME","FLOW_CONTROL_TRACER_NAME","MIN_CONNECT_TIMEOUT_MS","INITIAL_BACKOFF_MS","BACKOFF_MULTIPLIER","MAX_BACKOFF_MS","BACKOFF_JITTER","KEEPALIVE_MAX_TIME_MS","KEEPALIVE_TIMEOUT_MS","HTTP2_HEADER_AUTHORITY","HTTP2_HEADER_CONTENT_TYPE","HTTP2_HEADER_METHOD","HTTP2_HEADER_PATH","HTTP2_HEADER_TE","HTTP2_HEADER_USER_AGENT","http2","constants","uniformRandom","min","max","Math","random","tooManyPingsData","Buffer","from","Subchannel","constructor","channelTarget","subchannelAddress","options","credentials","connectivity_state_1","IDLE","channelz_1","userAgent","filter","e","join","keepaliveTimeMs","keepaliveTimeoutMs","keepaliveWithoutCalls","keepaliveIntervalId","setTimeout","clearTimeout","keepaliveTimeoutId","backoffOptions","initialDelay","maxDelay","backoffTimeout","backoff_timeout_1","handleBackoffTimer","subchannelAddressString","subchannel_address_1","channelzEnabled","channelzTrace","channelzRef","getChannelzInfo","addTrace","trace","JSON","stringify","undefined","state","connectivityState","callTracker","children","childrenTracker","getChildLists","target","getChannelzSocketInfo","session","sessionSocket","socket","remoteAddress","remotePort","localAddress","localPort","tlsInfo","encrypted","tlsSocket","cipherInfo","getCipher","certificate","getCertificate","peerCertificate","getPeerCertificate","cipherSuiteStandardName","standardName","_a","cipherSuiteOtherName","name","localCertificate","raw","remoteCertificate","socketInfo","security","remoteName","streamsStarted","streamTracker","callsStarted","streamsSucceeded","callsSucceeded","streamsFailed","callsFailed","messagesSent","messagesReceived","keepAlivesSent","keepalivesSent","lastLocalStreamCreatedTimestamp","lastCallStartedTimestamp","lastRemoteStreamCreatedTimestamp","lastMessageSentTimestamp","lastMessageReceivedTimestamp","localFlowControlWindow","localWindowSize","_b","remoteFlowControlWindow","remoteWindowSize","_c","resetChannelzSocketInfo","channelzSocketRef","unrefChild","text","logging","constants_1","DEBUG","id","refTrace","flowControlTrace","internalsTrace","keepaliveTrace","continueConnecting","transitionToState","TRANSIENT_FAILURE","CONNECTING","startBackoff","runOnce","stopBackoff","stop","reset","sendPing","handleDisconnect","unref","ping","err","duration","payload","startKeepalivePings","setInterval","stopKeepalivePings","clearInterval","createSession","proxyConnectionResult","realTarget","uri_parser_1","targetAuthority","resolver_1","connectionOptions","_getConnectionOptions","maxSendHeaderBlockLength","Number","MAX_SAFE_INTEGER","maxSessionMemory","addressScheme","sslTargetNameOverride","checkServerIdentity","host","cert","tls_1","servername","authorityHostname","createConnection","authority","option","net","connect","refChild","once","READY","errorCode","lastStreamID","opaqueData","NGHTTP2_ENHANCE_YOUR_CALM","equals","log","ERROR","error","message","isTracerEnabled","on","settings","startConnectingInternal","ALPNProtocols","targetPath","path","hostPort","http_proxy_1","then","result","reason","listener","disconnectListeners","oldStates","newState","indexOf","previousState","close","isRunning","process","nextTick","Error","stateListeners","checkBothRefcounts","callRefcount","refcount","callRef","ref","callUnref","unrefIfOneRef","startCallStream","metadata","callStream","extraFilters","headers","toHttp2Headers","getHost","getMethod","http2Stream","request","headersString","header","Object","keys","getCallNumber","streamSession","closed","destroyed","statsTracker","addCallStarted","addStatusWatcher","status","code","OK","addCallSucceeded","addCallFailed","addStreamEndWatcher","success","addMessageSent","Date","addMessageReceived","attachHttp2Stream","startConnecting","getConnectivityState","addConnectivityStateListener","push","removeConnectivityStateListener","listenerIndex","splice","addDisconnectListener","removeDisconnectListener","resetBackoff","getAddress","getChannelzRef","getRealSubchannel","exports"],"sources":["C:\\Users\\binel\\OneDrive\\Desktop\\Today\\Udemy\\iProfiler\\iProfiler\\iprofiler\\node_modules\\@grpc\\grpc-js\\src\\subchannel.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as http2 from 'http2';\nimport { ChannelCredentials } from './channel-credentials';\nimport { Metadata } from './metadata';\nimport { Call, Http2CallStream, WriteObject } from './call-stream';\nimport { ChannelOptions } from './channel-options';\nimport { PeerCertificate, checkServerIdentity, TLSSocket, CipherNameAndProtocol } from 'tls';\nimport { ConnectivityState } from './connectivity-state';\nimport { BackoffTimeout, BackoffOptions } from './backoff-timeout';\nimport { getDefaultAuthority } from './resolver';\nimport * as logging from './logging';\nimport { LogVerbosity, Status } from './constants';\nimport { getProxiedConnection, ProxyConnectionResult } from './http_proxy';\nimport * as net from 'net';\nimport { GrpcUri, parseUri, splitHostPort, uriToString } from './uri-parser';\nimport { ConnectionOptions } from 'tls';\nimport { FilterFactory, Filter, BaseFilter } from './filter';\nimport {\n  stringToSubchannelAddress,\n  SubchannelAddress,\n  subchannelAddressToString,\n} from './subchannel-address';\nimport { SubchannelRef, ChannelzTrace, ChannelzChildrenTracker, SubchannelInfo, registerChannelzSubchannel, ChannelzCallTracker, SocketInfo, SocketRef, unregisterChannelzRef, registerChannelzSocket, TlsInfo } from './channelz';\nimport { ConnectivityStateListener } from './subchannel-interface';\n\nconst clientVersion = require('../../package.json').version;\n\nconst TRACER_NAME = 'subchannel';\nconst FLOW_CONTROL_TRACER_NAME = 'subchannel_flowctrl';\n\nconst MIN_CONNECT_TIMEOUT_MS = 20000;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\n\nexport interface SubchannelCallStatsTracker {\n  addMessageSent(): void;\n  addMessageReceived(): void;\n}\n\nconst {\n  HTTP2_HEADER_AUTHORITY,\n  HTTP2_HEADER_CONTENT_TYPE,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_TE,\n  HTTP2_HEADER_USER_AGENT,\n} = http2.constants;\n\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\nfunction uniformRandom(min: number, max: number) {\n  return Math.random() * (max - min) + min;\n}\n\nconst tooManyPingsData: Buffer = Buffer.from('too_many_pings', 'ascii');\n\nexport class Subchannel {\n  /**\n   * The subchannel's current connectivity state. Invariant: `session` === `null`\n   * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n   */\n  private connectivityState: ConnectivityState = ConnectivityState.IDLE;\n  /**\n   * The underlying http2 session used to make requests.\n   */\n  private session: http2.ClientHttp2Session | null = null;\n  /**\n   * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n   * CONNECTING instead of IDLE when the backoff timeout ends.\n   */\n  private continueConnecting = false;\n  /**\n   * A list of listener functions that will be called whenever the connectivity\n   * state changes. Will be modified by `addConnectivityStateListener` and\n   * `removeConnectivityStateListener`\n   */\n  private stateListeners: ConnectivityStateListener[] = [];\n\n  /**\n   * A list of listener functions that will be called when the underlying\n   * socket disconnects. Used for ending active calls with an UNAVAILABLE\n   * status.\n   */\n  private disconnectListeners: Array<() => void> = [];\n\n  private backoffTimeout: BackoffTimeout;\n\n  /**\n   * The complete user agent string constructed using channel args.\n   */\n  private userAgent: string;\n\n  /**\n   * The amount of time in between sending pings\n   */\n  private keepaliveTimeMs: number = KEEPALIVE_MAX_TIME_MS;\n  /**\n   * The amount of time to wait for an acknowledgement after sending a ping\n   */\n  private keepaliveTimeoutMs: number = KEEPALIVE_TIMEOUT_MS;\n  /**\n   * Timer reference for timeout that indicates when to send the next ping\n   */\n  private keepaliveIntervalId: NodeJS.Timer;\n  /**\n   * Timer reference tracking when the most recent ping will be considered lost\n   */\n  private keepaliveTimeoutId: NodeJS.Timer;\n  /**\n   * Indicates whether keepalive pings should be sent without any active calls\n   */\n  private keepaliveWithoutCalls = false;\n\n  /**\n   * Tracks calls with references to this subchannel\n   */\n  private callRefcount = 0;\n  /**\n   * Tracks channels and subchannel pools with references to this subchannel\n   */\n  private refcount = 0;\n\n  /**\n   * A string representation of the subchannel address, for logging/tracing\n   */\n  private subchannelAddressString: string;\n\n  // Channelz info\n  private readonly channelzEnabled: boolean = true;\n  private channelzRef: SubchannelRef;\n  private channelzTrace: ChannelzTrace;\n  private callTracker = new ChannelzCallTracker();\n  private childrenTracker = new ChannelzChildrenTracker();\n\n  // Channelz socket info\n  private channelzSocketRef: SocketRef | null = null;\n  /**\n   * Name of the remote server, if it is not the same as the subchannel\n   * address, i.e. if connecting through an HTTP CONNECT proxy.\n   */\n  private remoteName: string | null = null;\n  private streamTracker = new ChannelzCallTracker();\n  private keepalivesSent = 0;\n  private messagesSent = 0;\n  private messagesReceived = 0;\n  private lastMessageSentTimestamp: Date | null = null;\n  private lastMessageReceivedTimestamp: Date | null = null;\n\n  /**\n   * A class representing a connection to a single backend.\n   * @param channelTarget The target string for the channel as a whole\n   * @param subchannelAddress The address for the backend that this subchannel\n   *     will connect to\n   * @param options The channel options, plus any specific subchannel options\n   *     for this subchannel\n   * @param credentials The channel credentials used to establish this\n   *     connection\n   */\n  constructor(\n    private channelTarget: GrpcUri,\n    private subchannelAddress: SubchannelAddress,\n    private options: ChannelOptions,\n    private credentials: ChannelCredentials\n  ) {\n    // Build user-agent string.\n    this.userAgent = [\n      options['grpc.primary_user_agent'],\n      `grpc-node-js/${clientVersion}`,\n      options['grpc.secondary_user_agent'],\n    ]\n      .filter((e) => e)\n      .join(' '); // remove falsey values first\n\n    if ('grpc.keepalive_time_ms' in options) {\n      this.keepaliveTimeMs = options['grpc.keepalive_time_ms']!;\n    }\n    if ('grpc.keepalive_timeout_ms' in options) {\n      this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms']!;\n    }\n    if ('grpc.keepalive_permit_without_calls' in options) {\n      this.keepaliveWithoutCalls =\n        options['grpc.keepalive_permit_without_calls'] === 1;\n    } else {\n      this.keepaliveWithoutCalls = false;\n    }\n    this.keepaliveIntervalId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveIntervalId);\n    this.keepaliveTimeoutId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveTimeoutId);\n    const backoffOptions: BackoffOptions = {\n      initialDelay: options['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: options['grpc.max_reconnect_backoff_ms'],\n    };\n    this.backoffTimeout = new BackoffTimeout(() => {\n      this.handleBackoffTimer();\n    }, backoffOptions);\n    this.subchannelAddressString = subchannelAddressToString(subchannelAddress);\n\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzTrace = new ChannelzTrace();\n    this.channelzRef = registerChannelzSubchannel(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');\n    }\n    this.trace('Subchannel constructed with options ' + JSON.stringify(options, undefined, 2));\n  }\n\n  private getChannelzInfo(): SubchannelInfo {\n    return {\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists(),\n      target: this.subchannelAddressString\n    };\n  }\n\n  private getChannelzSocketInfo(): SocketInfo | null {\n    if (this.session === null) {\n      return null;\n    }\n    const sessionSocket = this.session.socket;\n    const remoteAddress = sessionSocket.remoteAddress ? stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n    const localAddress = sessionSocket.localAddress ? stringToSubchannelAddress(sessionSocket.localAddress, sessionSocket.localPort) : null;\n    let tlsInfo: TlsInfo | null;\n    if (this.session.encrypted) {\n      const tlsSocket: TLSSocket = sessionSocket as TLSSocket;\n      const cipherInfo: CipherNameAndProtocol & {standardName?: string} = tlsSocket.getCipher();\n      const certificate = tlsSocket.getCertificate();\n      const peerCertificate = tlsSocket.getPeerCertificate();\n      tlsInfo = {\n        cipherSuiteStandardName: cipherInfo.standardName ?? null,\n        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n        localCertificate: (certificate && 'raw' in certificate) ? certificate.raw : null,\n        remoteCertificate: (peerCertificate && 'raw' in peerCertificate) ? peerCertificate.raw : null\n      };\n    } else {\n      tlsInfo = null;\n    }\n    const socketInfo: SocketInfo = {\n      remoteAddress: remoteAddress,\n      localAddress: localAddress,\n      security: tlsInfo,\n      remoteName: this.remoteName,\n      streamsStarted: this.streamTracker.callsStarted,\n      streamsSucceeded: this.streamTracker.callsSucceeded,\n      streamsFailed: this.streamTracker.callsFailed,\n      messagesSent: this.messagesSent,\n      messagesReceived: this.messagesReceived,\n      keepAlivesSent: this.keepalivesSent,\n      lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\n      lastRemoteStreamCreatedTimestamp: null,\n      lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n      lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n      localFlowControlWindow: this.session.state.localWindowSize ?? null,\n      remoteFlowControlWindow: this.session.state.remoteWindowSize ?? null\n    };\n    return socketInfo;\n  }\n\n  private resetChannelzSocketInfo() {\n    if (!this.channelzEnabled) {\n      return;\n    }\n    if (this.channelzSocketRef) {\n      unregisterChannelzRef(this.channelzSocketRef);\n      this.childrenTracker.unrefChild(this.channelzSocketRef);\n      this.channelzSocketRef = null;\n    }\n    this.remoteName = null;\n    this.streamTracker = new ChannelzCallTracker();\n    this.keepalivesSent = 0;\n    this.messagesSent = 0;\n    this.messagesReceived = 0;\n    this.lastMessageSentTimestamp = null;\n    this.lastMessageReceivedTimestamp = null;\n  }\n\n  private trace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private refTrace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, 'subchannel_refcount', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private flowControlTrace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private internalsTrace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, 'subchannel_internals', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private keepaliveTrace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, 'keepalive', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private handleBackoffTimer() {\n    if (this.continueConnecting) {\n      this.transitionToState(\n        [ConnectivityState.TRANSIENT_FAILURE],\n        ConnectivityState.CONNECTING\n      );\n    } else {\n      this.transitionToState(\n        [ConnectivityState.TRANSIENT_FAILURE],\n        ConnectivityState.IDLE\n      );\n    }\n  }\n\n  /**\n   * Start a backoff timer with the current nextBackoff timeout\n   */\n  private startBackoff() {\n    this.backoffTimeout.runOnce();\n  }\n\n  private stopBackoff() {\n    this.backoffTimeout.stop();\n    this.backoffTimeout.reset();\n  }\n\n  private sendPing() {\n    if (this.channelzEnabled) {\n      this.keepalivesSent += 1;\n    }\n    this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\n    this.keepaliveTimeoutId = setTimeout(() => {\n      this.keepaliveTrace('Ping timeout passed without response');\n      this.handleDisconnect();\n    }, this.keepaliveTimeoutMs);\n    this.keepaliveTimeoutId.unref?.();\n    this.session!.ping(\n      (err: Error | null, duration: number, payload: Buffer) => {\n        this.keepaliveTrace('Received ping response');\n        clearTimeout(this.keepaliveTimeoutId);\n      }\n    );\n  }\n\n  private startKeepalivePings() {\n    this.keepaliveIntervalId = setInterval(() => {\n      this.sendPing();\n    }, this.keepaliveTimeMs);\n    this.keepaliveIntervalId.unref?.();\n    /* Don't send a ping immediately because whatever caused us to start\n     * sending pings should also involve some network activity. */\n  }\n\n  /**\n   * Stop keepalive pings when terminating a connection. This discards the\n   * outstanding ping timeout, so it should not be called if the same\n   * connection will still be used.\n   */\n  private stopKeepalivePings() {\n    clearInterval(this.keepaliveIntervalId);\n    clearTimeout(this.keepaliveTimeoutId);\n  }\n\n  private createSession(proxyConnectionResult: ProxyConnectionResult) {\n    if (proxyConnectionResult.realTarget) {\n      this.remoteName = uriToString(proxyConnectionResult.realTarget);\n      this.trace('creating HTTP/2 session through proxy to ' + proxyConnectionResult.realTarget);\n    } else {\n      this.remoteName = null;\n      this.trace('creating HTTP/2 session');\n    }\n    const targetAuthority = getDefaultAuthority(\n      proxyConnectionResult.realTarget ?? this.channelTarget\n    );\n    let connectionOptions: http2.SecureClientSessionOptions =\n      this.credentials._getConnectionOptions() || {};\n    connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;\n    if ('grpc-node.max_session_memory' in this.options) {\n      connectionOptions.maxSessionMemory = this.options[\n        'grpc-node.max_session_memory'\n      ];\n    } else {\n      /* By default, set a very large max session memory limit, to effectively\n       * disable enforcement of the limit. Some testing indicates that Node's\n       * behavior degrades badly when this limit is reached, so we solve that\n       * by disabling the check entirely. */\n      connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n    }\n    let addressScheme = 'http://';\n    if ('secureContext' in connectionOptions) {\n      addressScheme = 'https://';\n      // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n      if (this.options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = this.options[\n          'grpc.ssl_target_name_override'\n        ]!;\n        connectionOptions.checkServerIdentity = (\n          host: string,\n          cert: PeerCertificate\n        ): Error | undefined => {\n          return checkServerIdentity(sslTargetNameOverride, cert);\n        };\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        const authorityHostname =\n          splitHostPort(targetAuthority)?.host ?? 'localhost';\n        // We want to always set servername to support SNI\n        connectionOptions.servername = authorityHostname;\n      }\n      if (proxyConnectionResult.socket) {\n        /* This is part of the workaround for\n         * https://github.com/nodejs/node/issues/32922. Without that bug,\n         * proxyConnectionResult.socket would always be a plaintext socket and\n         * this would say\n         * connectionOptions.socket = proxyConnectionResult.socket; */\n        connectionOptions.createConnection = (authority, option) => {\n          return proxyConnectionResult.socket!;\n        };\n      }\n    } else {\n      /* In all but the most recent versions of Node, http2.connect does not use\n       * the options when establishing plaintext connections, so we need to\n       * establish that connection explicitly. */\n      connectionOptions.createConnection = (authority, option) => {\n        if (proxyConnectionResult.socket) {\n          return proxyConnectionResult.socket;\n        } else {\n          /* net.NetConnectOpts is declared in a way that is more restrictive\n           * than what net.connect will actually accept, so we use the type\n           * assertion to work around that. */\n          return net.connect(this.subchannelAddress);\n        }\n      };\n    }\n\n    connectionOptions = {\n      ...connectionOptions,\n      ...this.subchannelAddress,\n    };\n\n    /* http2.connect uses the options here:\n     * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n     * The spread operator overides earlier values with later ones, so any port\n     * or host values in the options will be used rather than any values extracted\n     * from the first argument. In addition, the path overrides the host and port,\n     * as documented for plaintext connections here:\n     * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n     * and for TLS connections here:\n     * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n     * earlier versions of Node, http2.connect passes these options to\n     * tls.connect but not net.connect, so in the insecure case we still need\n     * to set the createConnection option above to create the connection\n     * explicitly. We cannot do that in the TLS case because http2.connect\n     * passes necessary additional options to tls.connect.\n     * The first argument just needs to be parseable as a URL and the scheme\n     * determines whether the connection will be established over TLS or not.\n     */\n    const session = http2.connect(\n      addressScheme + targetAuthority,\n      connectionOptions\n    );\n    this.session = session;\n    this.channelzSocketRef = registerChannelzSocket(this.subchannelAddressString, () => this.getChannelzSocketInfo()!, this.channelzEnabled);\n    if (this.channelzEnabled) {\n      this.childrenTracker.refChild(this.channelzSocketRef);\n    }\n    session.unref();\n    /* For all of these events, check if the session at the time of the event\n     * is the same one currently attached to this subchannel, to ensure that\n     * old events from previous connection attempts cannot cause invalid state\n     * transitions. */\n    session.once('connect', () => {\n      if (this.session === session) {\n        this.transitionToState(\n          [ConnectivityState.CONNECTING],\n          ConnectivityState.READY\n        );\n      }\n    });\n    session.once('close', () => {\n      if (this.session === session) {\n        this.trace('connection closed');\n        this.transitionToState(\n          [ConnectivityState.CONNECTING],\n          ConnectivityState.TRANSIENT_FAILURE\n        );\n        /* Transitioning directly to IDLE here should be OK because we are not\n         * doing any backoff, because a connection was established at some\n         * point */\n        this.transitionToState(\n          [ConnectivityState.READY],\n          ConnectivityState.IDLE\n        );\n      }\n    });\n    session.once(\n      'goaway',\n      (errorCode: number, lastStreamID: number, opaqueData: Buffer) => {\n        if (this.session === session) {\n          /* See the last paragraph of\n           * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n          if (\n            errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM &&\n            opaqueData.equals(tooManyPingsData)\n          ) {\n            this.keepaliveTimeMs = Math.min(\n              2 * this.keepaliveTimeMs,\n              KEEPALIVE_MAX_TIME_MS\n            );\n            logging.log(\n              LogVerbosity.ERROR,\n              `Connection to ${uriToString(this.channelTarget)} at ${\n                this.subchannelAddressString\n              } rejected by server because of excess pings. Increasing ping interval to ${\n                this.keepaliveTimeMs\n              } ms`\n            );\n          }\n          this.trace(\n            'connection closed by GOAWAY with code ' +\n              errorCode\n          );\n          this.transitionToState(\n            [ConnectivityState.CONNECTING, ConnectivityState.READY],\n            ConnectivityState.IDLE\n          );\n        }\n      }\n    );\n    session.once('error', (error) => {\n      /* Do nothing here. Any error should also trigger a close event, which is\n       * where we want to handle that.  */\n      this.trace(\n        'connection closed with error ' +\n          (error as Error).message\n      );\n    });\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      session.on('remoteSettings', (settings: http2.Settings) => {\n        this.trace(\n          'new settings received' +\n            (this.session !== session ? ' on the old connection' : '') +\n            ': ' +\n            JSON.stringify(settings)\n        );\n      });\n      session.on('localSettings', (settings: http2.Settings) => {\n        this.trace(\n          'local settings acknowledged by remote' +\n            (this.session !== session ? ' on the old connection' : '') +\n            ': ' +\n            JSON.stringify(settings)\n        );\n      });\n    }\n  }\n\n  private startConnectingInternal() {\n    /* Pass connection options through to the proxy so that it's able to\n     * upgrade it's connection to support tls if needed.\n     * This is a workaround for https://github.com/nodejs/node/issues/32922\n     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n    const connectionOptions: ConnectionOptions =\n      this.credentials._getConnectionOptions() || {};\n\n    if ('secureContext' in connectionOptions) {\n      connectionOptions.ALPNProtocols = ['h2'];\n      // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n      if (this.options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = this.options[\n          'grpc.ssl_target_name_override'\n        ]!;\n        connectionOptions.checkServerIdentity = (\n          host: string,\n          cert: PeerCertificate\n        ): Error | undefined => {\n          return checkServerIdentity(sslTargetNameOverride, cert);\n        };\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        if ('grpc.http_connect_target' in this.options) {\n          /* This is more or less how servername will be set in createSession\n           * if a connection is successfully established through the proxy.\n           * If the proxy is not used, these connectionOptions are discarded\n           * anyway */\n          const targetPath = getDefaultAuthority(\n            parseUri(this.options['grpc.http_connect_target'] as string) ?? {\n              path: 'localhost',\n            }\n          );\n          const hostPort = splitHostPort(targetPath);\n          connectionOptions.servername = hostPort?.host ?? targetPath;\n        }\n      }\n    }\n\n    getProxiedConnection(\n      this.subchannelAddress,\n      this.options,\n      connectionOptions\n    ).then(\n      (result) => {\n        this.createSession(result);\n      },\n      (reason) => {\n        this.transitionToState(\n          [ConnectivityState.CONNECTING],\n          ConnectivityState.TRANSIENT_FAILURE\n        );\n      }\n    );\n  }\n\n  private handleDisconnect() {\n    this.transitionToState(\n      [ConnectivityState.READY],\n      ConnectivityState.TRANSIENT_FAILURE);\n    for (const listener of this.disconnectListeners) {\n      listener();\n    }\n  }\n\n  /**\n   * Initiate a state transition from any element of oldStates to the new\n   * state. If the current connectivityState is not in oldStates, do nothing.\n   * @param oldStates The set of states to transition from\n   * @param newState The state to transition to\n   * @returns True if the state changed, false otherwise\n   */\n  private transitionToState(\n    oldStates: ConnectivityState[],\n    newState: ConnectivityState\n  ): boolean {\n    if (oldStates.indexOf(this.connectivityState) === -1) {\n      return false;\n    }\n    this.trace(\n      ConnectivityState[this.connectivityState] +\n        ' -> ' +\n        ConnectivityState[newState]\n    );\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', ConnectivityState[this.connectivityState] + ' -> ' + ConnectivityState[newState]);\n    }\n    const previousState = this.connectivityState;\n    this.connectivityState = newState;\n    switch (newState) {\n      case ConnectivityState.READY:\n        this.stopBackoff();\n        const session = this.session!;\n        session.socket.once('close', () => {\n          if (this.session === session) {\n            this.handleDisconnect();\n          }\n        });\n        if (this.keepaliveWithoutCalls) {\n          this.startKeepalivePings();\n        }\n        break;\n      case ConnectivityState.CONNECTING:\n        this.startBackoff();\n        this.startConnectingInternal();\n        this.continueConnecting = false;\n        break;\n      case ConnectivityState.TRANSIENT_FAILURE:\n        if (this.session) {\n          this.session.close();\n        }\n        this.session = null;\n        this.resetChannelzSocketInfo();\n        this.stopKeepalivePings();\n        /* If the backoff timer has already ended by the time we get to the\n         * TRANSIENT_FAILURE state, we want to immediately transition out of\n         * TRANSIENT_FAILURE as though the backoff timer is ending right now */\n        if (!this.backoffTimeout.isRunning()) {\n          process.nextTick(() => {\n            this.handleBackoffTimer();\n          });\n        }\n        break;\n      case ConnectivityState.IDLE:\n        if (this.session) {\n          this.session.close();\n        }\n        this.session = null;\n        this.resetChannelzSocketInfo();\n        this.stopKeepalivePings();\n        break;\n      default:\n        throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n    }\n    /* We use a shallow copy of the stateListeners array in case a listener\n     * is removed during this iteration */\n    for (const listener of [...this.stateListeners]) {\n      listener(this, previousState, newState);\n    }\n    return true;\n  }\n\n  /**\n   * Check if the subchannel associated with zero calls and with zero channels.\n   * If so, shut it down.\n   */\n  private checkBothRefcounts() {\n    /* If no calls, channels, or subchannel pools have any more references to\n     * this subchannel, we can be sure it will never be used again. */\n    if (this.callRefcount === 0 && this.refcount === 0) {\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Shutting down');\n      }\n      this.transitionToState(\n        [ConnectivityState.CONNECTING, ConnectivityState.READY],\n        ConnectivityState.IDLE\n      );\n      if (this.channelzEnabled) {\n        unregisterChannelzRef(this.channelzRef);\n      }\n    }\n  }\n\n  callRef() {\n    this.refTrace(\n      'callRefcount ' +\n        this.callRefcount +\n        ' -> ' +\n        (this.callRefcount + 1)\n    );\n    if (this.callRefcount === 0) {\n      if (this.session) {\n        this.session.ref();\n      }\n      this.backoffTimeout.ref();\n      if (!this.keepaliveWithoutCalls) {\n        this.startKeepalivePings();\n      }\n    }\n    this.callRefcount += 1;\n  }\n\n  callUnref() {\n    this.refTrace(\n      'callRefcount ' +\n        this.callRefcount +\n        ' -> ' +\n        (this.callRefcount - 1)\n    );\n    this.callRefcount -= 1;\n    if (this.callRefcount === 0) {\n      if (this.session) {\n        this.session.unref();\n      }\n      this.backoffTimeout.unref();\n      if (!this.keepaliveWithoutCalls) {\n        clearInterval(this.keepaliveIntervalId);\n      }\n      this.checkBothRefcounts();\n    }\n  }\n\n  ref() {\n    this.refTrace(\n      'refcount ' +\n        this.refcount +\n        ' -> ' +\n        (this.refcount + 1)\n    );\n    this.refcount += 1;\n  }\n\n  unref() {\n    this.refTrace(\n      'refcount ' +\n        this.refcount +\n        ' -> ' +\n        (this.refcount - 1)\n    );\n    this.refcount -= 1;\n    this.checkBothRefcounts();\n  }\n\n  unrefIfOneRef(): boolean {\n    if (this.refcount === 1) {\n      this.unref();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Start a stream on the current session with the given `metadata` as headers\n   * and then attach it to the `callStream`. Must only be called if the\n   * subchannel's current connectivity state is READY.\n   * @param metadata\n   * @param callStream\n   */\n  startCallStream(\n    metadata: Metadata,\n    callStream: Http2CallStream,\n    extraFilters: Filter[]\n  ) {\n    const headers = metadata.toHttp2Headers();\n    headers[HTTP2_HEADER_AUTHORITY] = callStream.getHost();\n    headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n    headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n    headers[HTTP2_HEADER_METHOD] = 'POST';\n    headers[HTTP2_HEADER_PATH] = callStream.getMethod();\n    headers[HTTP2_HEADER_TE] = 'trailers';\n    let http2Stream: http2.ClientHttp2Stream;\n    /* In theory, if an error is thrown by session.request because session has\n     * become unusable (e.g. because it has received a goaway), this subchannel\n     * should soon see the corresponding close or goaway event anyway and leave\n     * READY. But we have seen reports that this does not happen\n     * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n     * so for defense in depth, we just discard the session when we see an\n     * error here.\n     */\n    try {\n      http2Stream = this.session!.request(headers);\n    } catch (e) {\n      this.transitionToState(\n        [ConnectivityState.READY],\n        ConnectivityState.TRANSIENT_FAILURE\n      );\n      throw e;\n    }\n    let headersString = '';\n    for (const header of Object.keys(headers)) {\n      headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n    }\n    logging.trace(\n      LogVerbosity.DEBUG,\n      'call_stream',\n      'Starting stream [' + callStream.getCallNumber() + '] on subchannel ' +\n        '(' + this.channelzRef.id + ') ' +\n        this.subchannelAddressString +\n        ' with headers\\n' +\n        headersString\n    );\n    this.flowControlTrace(\n      'local window size: ' +\n        this.session!.state.localWindowSize +\n        ' remote window size: ' +\n        this.session!.state.remoteWindowSize\n    );\n    const streamSession = this.session;\n    this.internalsTrace(\n      'session.closed=' + \n      streamSession!.closed + \n      ' session.destroyed=' + \n      streamSession!.destroyed + \n      ' session.socket.destroyed=' + \n      streamSession!.socket.destroyed);\n    let statsTracker: SubchannelCallStatsTracker;\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      callStream.addStatusWatcher(status => {\n        if (status.code === Status.OK) {\n          this.callTracker.addCallSucceeded();\n        } else {\n          this.callTracker.addCallFailed();\n        }\n      });\n      this.streamTracker.addCallStarted();\n      callStream.addStreamEndWatcher(success => {\n        if (streamSession === this.session) {\n          if (success) {\n            this.streamTracker.addCallSucceeded();\n          } else {\n            this.streamTracker.addCallFailed();\n          }\n        }\n      });\n      statsTracker = {\n        addMessageSent: () => {\n          this.messagesSent += 1;\n          this.lastMessageSentTimestamp = new Date();\n        },\n        addMessageReceived: () => {\n          this.messagesReceived += 1;\n        }\n      }\n    } else {\n      statsTracker = {\n        addMessageSent: () => {},\n        addMessageReceived: () => {}\n      }\n    }\n    callStream.attachHttp2Stream(http2Stream, this, extraFilters, statsTracker);\n  }\n\n  /**\n   * If the subchannel is currently IDLE, start connecting and switch to the\n   * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n   * the next time it would transition to IDLE, start connecting again instead.\n   * Otherwise, do nothing.\n   */\n  startConnecting() {\n    /* First, try to transition from IDLE to connecting. If that doesn't happen\n     * because the state is not currently IDLE, check if it is\n     * TRANSIENT_FAILURE, and if so indicate that it should go back to\n     * connecting after the backoff timer ends. Otherwise do nothing */\n    if (\n      !this.transitionToState(\n        [ConnectivityState.IDLE],\n        ConnectivityState.CONNECTING\n      )\n    ) {\n      if (this.connectivityState === ConnectivityState.TRANSIENT_FAILURE) {\n        this.continueConnecting = true;\n      }\n    }\n  }\n\n  /**\n   * Get the subchannel's current connectivity state.\n   */\n  getConnectivityState() {\n    return this.connectivityState;\n  }\n\n  /**\n   * Add a listener function to be called whenever the subchannel's\n   * connectivity state changes.\n   * @param listener\n   */\n  addConnectivityStateListener(listener: ConnectivityStateListener) {\n    this.stateListeners.push(listener);\n  }\n\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n  removeConnectivityStateListener(listener: ConnectivityStateListener) {\n    const listenerIndex = this.stateListeners.indexOf(listener);\n    if (listenerIndex > -1) {\n      this.stateListeners.splice(listenerIndex, 1);\n    }\n  }\n\n  addDisconnectListener(listener: () => void) {\n    this.disconnectListeners.push(listener);\n  }\n\n  removeDisconnectListener(listener: () => void) {\n    const listenerIndex = this.disconnectListeners.indexOf(listener);\n    if (listenerIndex > -1) {\n      this.disconnectListeners.splice(listenerIndex, 1);\n    }\n  }\n\n  /**\n   * Reset the backoff timeout, and immediately start connecting if in backoff.\n   */\n  resetBackoff() {\n    this.backoffTimeout.reset();\n    this.transitionToState(\n      [ConnectivityState.TRANSIENT_FAILURE],\n      ConnectivityState.CONNECTING\n    );\n  }\n\n  getAddress(): string {\n    return this.subchannelAddressString;\n  }\n\n  getChannelzRef(): SubchannelRef {\n    return this.channelzRef;\n  }\n\n  getRealSubchannel(): this {\n    return this;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}