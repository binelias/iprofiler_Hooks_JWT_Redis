{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setup = exports.getChannelzServiceDefinition = exports.getChannelzHandlers = exports.unregisterChannelzRef = exports.registerChannelzSocket = exports.registerChannelzServer = exports.registerChannelzSubchannel = exports.registerChannelzChannel = exports.ChannelzCallTracker = exports.ChannelzChildrenTracker = exports.ChannelzTrace = void 0;\n\nconst net_1 = require(\"net\");\n\nconst connectivity_state_1 = require(\"./connectivity-state\");\n\nconst constants_1 = require(\"./constants\");\n\nconst subchannel_address_1 = require(\"./subchannel-address\");\n\nconst admin_1 = require(\"./admin\");\n\nconst make_client_1 = require(\"./make-client\");\n\nfunction channelRefToMessage(ref) {\n  return {\n    channel_id: ref.id,\n    name: ref.name\n  };\n}\n\nfunction subchannelRefToMessage(ref) {\n  return {\n    subchannel_id: ref.id,\n    name: ref.name\n  };\n}\n\nfunction serverRefToMessage(ref) {\n  return {\n    server_id: ref.id\n  };\n}\n\nfunction socketRefToMessage(ref) {\n  return {\n    socket_id: ref.id,\n    name: ref.name\n  };\n}\n/**\n * The loose upper bound on the number of events that should be retained in a\n * trace. This may be exceeded by up to a factor of 2. Arbitrarily chosen as a\n * number that should be large enough to contain the recent relevant\n * information, but small enough to not use excessive memory.\n */\n\n\nconst TARGET_RETAINED_TRACES = 32;\n\nclass ChannelzTrace {\n  constructor() {\n    this.events = [];\n    this.eventsLogged = 0;\n    this.creationTimestamp = new Date();\n  }\n\n  addTrace(severity, description, child) {\n    const timestamp = new Date();\n    this.events.push({\n      description: description,\n      severity: severity,\n      timestamp: timestamp,\n      childChannel: (child === null || child === void 0 ? void 0 : child.kind) === 'channel' ? child : undefined,\n      childSubchannel: (child === null || child === void 0 ? void 0 : child.kind) === 'subchannel' ? child : undefined\n    }); // Whenever the trace array gets too large, discard the first half\n\n    if (this.events.length >= TARGET_RETAINED_TRACES * 2) {\n      this.events = this.events.slice(TARGET_RETAINED_TRACES);\n    }\n\n    this.eventsLogged += 1;\n  }\n\n  getTraceMessage() {\n    return {\n      creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),\n      num_events_logged: this.eventsLogged,\n      events: this.events.map(event => {\n        return {\n          description: event.description,\n          severity: event.severity,\n          timestamp: dateToProtoTimestamp(event.timestamp),\n          channel_ref: event.childChannel ? channelRefToMessage(event.childChannel) : null,\n          subchannel_ref: event.childSubchannel ? subchannelRefToMessage(event.childSubchannel) : null\n        };\n      })\n    };\n  }\n\n}\n\nexports.ChannelzTrace = ChannelzTrace;\n\nclass ChannelzChildrenTracker {\n  constructor() {\n    this.channelChildren = new Map();\n    this.subchannelChildren = new Map();\n    this.socketChildren = new Map();\n  }\n\n  refChild(child) {\n    var _a, _b, _c;\n\n    switch (child.kind) {\n      case 'channel':\n        {\n          let trackedChild = (_a = this.channelChildren.get(child.id)) !== null && _a !== void 0 ? _a : {\n            ref: child,\n            count: 0\n          };\n          trackedChild.count += 1;\n          this.channelChildren.set(child.id, trackedChild);\n          break;\n        }\n\n      case 'subchannel':\n        {\n          let trackedChild = (_b = this.subchannelChildren.get(child.id)) !== null && _b !== void 0 ? _b : {\n            ref: child,\n            count: 0\n          };\n          trackedChild.count += 1;\n          this.subchannelChildren.set(child.id, trackedChild);\n          break;\n        }\n\n      case 'socket':\n        {\n          let trackedChild = (_c = this.socketChildren.get(child.id)) !== null && _c !== void 0 ? _c : {\n            ref: child,\n            count: 0\n          };\n          trackedChild.count += 1;\n          this.socketChildren.set(child.id, trackedChild);\n          break;\n        }\n    }\n  }\n\n  unrefChild(child) {\n    switch (child.kind) {\n      case 'channel':\n        {\n          let trackedChild = this.channelChildren.get(child.id);\n\n          if (trackedChild !== undefined) {\n            trackedChild.count -= 1;\n\n            if (trackedChild.count === 0) {\n              this.channelChildren.delete(child.id);\n            } else {\n              this.channelChildren.set(child.id, trackedChild);\n            }\n          }\n\n          break;\n        }\n\n      case 'subchannel':\n        {\n          let trackedChild = this.subchannelChildren.get(child.id);\n\n          if (trackedChild !== undefined) {\n            trackedChild.count -= 1;\n\n            if (trackedChild.count === 0) {\n              this.subchannelChildren.delete(child.id);\n            } else {\n              this.subchannelChildren.set(child.id, trackedChild);\n            }\n          }\n\n          break;\n        }\n\n      case 'socket':\n        {\n          let trackedChild = this.socketChildren.get(child.id);\n\n          if (trackedChild !== undefined) {\n            trackedChild.count -= 1;\n\n            if (trackedChild.count === 0) {\n              this.socketChildren.delete(child.id);\n            } else {\n              this.socketChildren.set(child.id, trackedChild);\n            }\n          }\n\n          break;\n        }\n    }\n  }\n\n  getChildLists() {\n    const channels = [];\n\n    for (const {\n      ref\n    } of this.channelChildren.values()) {\n      channels.push(ref);\n    }\n\n    const subchannels = [];\n\n    for (const {\n      ref\n    } of this.subchannelChildren.values()) {\n      subchannels.push(ref);\n    }\n\n    const sockets = [];\n\n    for (const {\n      ref\n    } of this.socketChildren.values()) {\n      sockets.push(ref);\n    }\n\n    return {\n      channels,\n      subchannels,\n      sockets\n    };\n  }\n\n}\n\nexports.ChannelzChildrenTracker = ChannelzChildrenTracker;\n\nclass ChannelzCallTracker {\n  constructor() {\n    this.callsStarted = 0;\n    this.callsSucceeded = 0;\n    this.callsFailed = 0;\n    this.lastCallStartedTimestamp = null;\n  }\n\n  addCallStarted() {\n    this.callsStarted += 1;\n    this.lastCallStartedTimestamp = new Date();\n  }\n\n  addCallSucceeded() {\n    this.callsSucceeded += 1;\n  }\n\n  addCallFailed() {\n    this.callsFailed += 1;\n  }\n\n}\n\nexports.ChannelzCallTracker = ChannelzCallTracker;\nlet nextId = 1;\n\nfunction getNextId() {\n  return nextId++;\n}\n\nconst channels = [];\nconst subchannels = [];\nconst servers = [];\nconst sockets = [];\n\nfunction registerChannelzChannel(name, getInfo, channelzEnabled) {\n  const id = getNextId();\n  const ref = {\n    id,\n    name,\n    kind: 'channel'\n  };\n\n  if (channelzEnabled) {\n    channels[id] = {\n      ref,\n      getInfo\n    };\n  }\n\n  return ref;\n}\n\nexports.registerChannelzChannel = registerChannelzChannel;\n\nfunction registerChannelzSubchannel(name, getInfo, channelzEnabled) {\n  const id = getNextId();\n  const ref = {\n    id,\n    name,\n    kind: 'subchannel'\n  };\n\n  if (channelzEnabled) {\n    subchannels[id] = {\n      ref,\n      getInfo\n    };\n  }\n\n  return ref;\n}\n\nexports.registerChannelzSubchannel = registerChannelzSubchannel;\n\nfunction registerChannelzServer(getInfo, channelzEnabled) {\n  const id = getNextId();\n  const ref = {\n    id,\n    kind: 'server'\n  };\n\n  if (channelzEnabled) {\n    servers[id] = {\n      ref,\n      getInfo\n    };\n  }\n\n  return ref;\n}\n\nexports.registerChannelzServer = registerChannelzServer;\n\nfunction registerChannelzSocket(name, getInfo, channelzEnabled) {\n  const id = getNextId();\n  const ref = {\n    id,\n    name,\n    kind: 'socket'\n  };\n\n  if (channelzEnabled) {\n    sockets[id] = {\n      ref,\n      getInfo\n    };\n  }\n\n  return ref;\n}\n\nexports.registerChannelzSocket = registerChannelzSocket;\n\nfunction unregisterChannelzRef(ref) {\n  switch (ref.kind) {\n    case 'channel':\n      delete channels[ref.id];\n      return;\n\n    case 'subchannel':\n      delete subchannels[ref.id];\n      return;\n\n    case 'server':\n      delete servers[ref.id];\n      return;\n\n    case 'socket':\n      delete sockets[ref.id];\n      return;\n  }\n}\n\nexports.unregisterChannelzRef = unregisterChannelzRef;\n/**\n * Parse a single section of an IPv6 address as two bytes\n * @param addressSection A hexadecimal string of length up to 4\n * @returns The pair of bytes representing this address section\n */\n\nfunction parseIPv6Section(addressSection) {\n  const numberValue = Number.parseInt(addressSection, 16);\n  return [numberValue / 256 | 0, numberValue % 256];\n}\n/**\n * Parse a chunk of an IPv6 address string to some number of bytes\n * @param addressChunk Some number of segments of up to 4 hexadecimal\n *   characters each, joined by colons.\n * @returns The list of bytes representing this address chunk\n */\n\n\nfunction parseIPv6Chunk(addressChunk) {\n  if (addressChunk === '') {\n    return [];\n  }\n\n  const bytePairs = addressChunk.split(':').map(section => parseIPv6Section(section));\n  const result = [];\n  return result.concat(...bytePairs);\n}\n/**\n * Converts an IPv4 or IPv6 address from string representation to binary\n * representation\n * @param ipAddress an IP address in standard IPv4 or IPv6 text format\n * @returns\n */\n\n\nfunction ipAddressStringToBuffer(ipAddress) {\n  if (net_1.isIPv4(ipAddress)) {\n    return Buffer.from(Uint8Array.from(ipAddress.split('.').map(segment => Number.parseInt(segment))));\n  } else if (net_1.isIPv6(ipAddress)) {\n    let leftSection;\n    let rightSection;\n    const doubleColonIndex = ipAddress.indexOf('::');\n\n    if (doubleColonIndex === -1) {\n      leftSection = ipAddress;\n      rightSection = '';\n    } else {\n      leftSection = ipAddress.substring(0, doubleColonIndex);\n      rightSection = ipAddress.substring(doubleColonIndex + 2);\n    }\n\n    const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));\n    const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));\n    const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);\n    return Buffer.concat([leftBuffer, middleBuffer, rightBuffer]);\n  } else {\n    return null;\n  }\n}\n\nfunction connectivityStateToMessage(state) {\n  switch (state) {\n    case connectivity_state_1.ConnectivityState.CONNECTING:\n      return {\n        state: 'CONNECTING'\n      };\n\n    case connectivity_state_1.ConnectivityState.IDLE:\n      return {\n        state: 'IDLE'\n      };\n\n    case connectivity_state_1.ConnectivityState.READY:\n      return {\n        state: 'READY'\n      };\n\n    case connectivity_state_1.ConnectivityState.SHUTDOWN:\n      return {\n        state: 'SHUTDOWN'\n      };\n\n    case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n      return {\n        state: 'TRANSIENT_FAILURE'\n      };\n\n    default:\n      return {\n        state: 'UNKNOWN'\n      };\n  }\n}\n\nfunction dateToProtoTimestamp(date) {\n  if (!date) {\n    return null;\n  }\n\n  const millisSinceEpoch = date.getTime();\n  return {\n    seconds: millisSinceEpoch / 1000 | 0,\n    nanos: millisSinceEpoch % 1000 * 1000000\n  };\n}\n\nfunction getChannelMessage(channelEntry) {\n  const resolvedInfo = channelEntry.getInfo();\n  return {\n    ref: channelRefToMessage(channelEntry.ref),\n    data: {\n      target: resolvedInfo.target,\n      state: connectivityStateToMessage(resolvedInfo.state),\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n      trace: resolvedInfo.trace.getTraceMessage()\n    },\n    channel_ref: resolvedInfo.children.channels.map(ref => channelRefToMessage(ref)),\n    subchannel_ref: resolvedInfo.children.subchannels.map(ref => subchannelRefToMessage(ref))\n  };\n}\n\nfunction GetChannel(call, callback) {\n  const channelId = Number.parseInt(call.request.channel_id);\n  const channelEntry = channels[channelId];\n\n  if (channelEntry === undefined) {\n    callback({\n      'code': constants_1.Status.NOT_FOUND,\n      'details': 'No channel data found for id ' + channelId\n    });\n    return;\n  }\n\n  callback(null, {\n    channel: getChannelMessage(channelEntry)\n  });\n}\n\nfunction GetTopChannels(call, callback) {\n  const maxResults = Number.parseInt(call.request.max_results);\n  const resultList = [];\n  let i = Number.parseInt(call.request.start_channel_id);\n\n  for (; i < channels.length; i++) {\n    const channelEntry = channels[i];\n\n    if (channelEntry === undefined) {\n      continue;\n    }\n\n    resultList.push(getChannelMessage(channelEntry));\n\n    if (resultList.length >= maxResults) {\n      break;\n    }\n  }\n\n  callback(null, {\n    channel: resultList,\n    end: i >= servers.length\n  });\n}\n\nfunction getServerMessage(serverEntry) {\n  const resolvedInfo = serverEntry.getInfo();\n  return {\n    ref: serverRefToMessage(serverEntry.ref),\n    data: {\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n      trace: resolvedInfo.trace.getTraceMessage()\n    },\n    listen_socket: resolvedInfo.listenerChildren.sockets.map(ref => socketRefToMessage(ref))\n  };\n}\n\nfunction GetServer(call, callback) {\n  const serverId = Number.parseInt(call.request.server_id);\n  const serverEntry = servers[serverId];\n\n  if (serverEntry === undefined) {\n    callback({\n      'code': constants_1.Status.NOT_FOUND,\n      'details': 'No server data found for id ' + serverId\n    });\n    return;\n  }\n\n  callback(null, {\n    server: getServerMessage(serverEntry)\n  });\n}\n\nfunction GetServers(call, callback) {\n  const maxResults = Number.parseInt(call.request.max_results);\n  const resultList = [];\n  let i = Number.parseInt(call.request.start_server_id);\n\n  for (; i < servers.length; i++) {\n    const serverEntry = servers[i];\n\n    if (serverEntry === undefined) {\n      continue;\n    }\n\n    resultList.push(getServerMessage(serverEntry));\n\n    if (resultList.length >= maxResults) {\n      break;\n    }\n  }\n\n  callback(null, {\n    server: resultList,\n    end: i >= servers.length\n  });\n}\n\nfunction GetSubchannel(call, callback) {\n  const subchannelId = Number.parseInt(call.request.subchannel_id);\n  const subchannelEntry = subchannels[subchannelId];\n\n  if (subchannelEntry === undefined) {\n    callback({\n      'code': constants_1.Status.NOT_FOUND,\n      'details': 'No subchannel data found for id ' + subchannelId\n    });\n    return;\n  }\n\n  const resolvedInfo = subchannelEntry.getInfo();\n  const subchannelMessage = {\n    ref: subchannelRefToMessage(subchannelEntry.ref),\n    data: {\n      target: resolvedInfo.target,\n      state: connectivityStateToMessage(resolvedInfo.state),\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n      trace: resolvedInfo.trace.getTraceMessage()\n    },\n    socket_ref: resolvedInfo.children.sockets.map(ref => socketRefToMessage(ref))\n  };\n  callback(null, {\n    subchannel: subchannelMessage\n  });\n}\n\nfunction subchannelAddressToAddressMessage(subchannelAddress) {\n  var _a;\n\n  if (subchannel_address_1.isTcpSubchannelAddress(subchannelAddress)) {\n    return {\n      address: 'tcpip_address',\n      tcpip_address: {\n        ip_address: (_a = ipAddressStringToBuffer(subchannelAddress.host)) !== null && _a !== void 0 ? _a : undefined,\n        port: subchannelAddress.port\n      }\n    };\n  } else {\n    return {\n      address: 'uds_address',\n      uds_address: {\n        filename: subchannelAddress.path\n      }\n    };\n  }\n}\n\nfunction GetSocket(call, callback) {\n  var _a, _b, _c, _d, _e;\n\n  const socketId = Number.parseInt(call.request.socket_id);\n  const socketEntry = sockets[socketId];\n\n  if (socketEntry === undefined) {\n    callback({\n      'code': constants_1.Status.NOT_FOUND,\n      'details': 'No socket data found for id ' + socketId\n    });\n    return;\n  }\n\n  const resolvedInfo = socketEntry.getInfo();\n  const securityMessage = resolvedInfo.security ? {\n    model: 'tls',\n    tls: {\n      cipher_suite: resolvedInfo.security.cipherSuiteStandardName ? 'standard_name' : 'other_name',\n      standard_name: (_a = resolvedInfo.security.cipherSuiteStandardName) !== null && _a !== void 0 ? _a : undefined,\n      other_name: (_b = resolvedInfo.security.cipherSuiteOtherName) !== null && _b !== void 0 ? _b : undefined,\n      local_certificate: (_c = resolvedInfo.security.localCertificate) !== null && _c !== void 0 ? _c : undefined,\n      remote_certificate: (_d = resolvedInfo.security.remoteCertificate) !== null && _d !== void 0 ? _d : undefined\n    }\n  } : null;\n  const socketMessage = {\n    ref: socketRefToMessage(socketEntry.ref),\n    local: resolvedInfo.localAddress ? subchannelAddressToAddressMessage(resolvedInfo.localAddress) : null,\n    remote: resolvedInfo.remoteAddress ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress) : null,\n    remote_name: (_e = resolvedInfo.remoteName) !== null && _e !== void 0 ? _e : undefined,\n    security: securityMessage,\n    data: {\n      keep_alives_sent: resolvedInfo.keepAlivesSent,\n      streams_started: resolvedInfo.streamsStarted,\n      streams_succeeded: resolvedInfo.streamsSucceeded,\n      streams_failed: resolvedInfo.streamsFailed,\n      last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),\n      last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),\n      messages_received: resolvedInfo.messagesReceived,\n      messages_sent: resolvedInfo.messagesSent,\n      last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),\n      last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),\n      local_flow_control_window: resolvedInfo.localFlowControlWindow ? {\n        value: resolvedInfo.localFlowControlWindow\n      } : null,\n      remote_flow_control_window: resolvedInfo.remoteFlowControlWindow ? {\n        value: resolvedInfo.remoteFlowControlWindow\n      } : null\n    }\n  };\n  callback(null, {\n    socket: socketMessage\n  });\n}\n\nfunction GetServerSockets(call, callback) {\n  const serverId = Number.parseInt(call.request.server_id);\n  const serverEntry = servers[serverId];\n\n  if (serverEntry === undefined) {\n    callback({\n      'code': constants_1.Status.NOT_FOUND,\n      'details': 'No server data found for id ' + serverId\n    });\n    return;\n  }\n\n  const startId = Number.parseInt(call.request.start_socket_id);\n  const maxResults = Number.parseInt(call.request.max_results);\n  const resolvedInfo = serverEntry.getInfo(); // If we wanted to include listener sockets in the result, this line would\n  // instead say\n  // const allSockets = resolvedInfo.listenerChildren.sockets.concat(resolvedInfo.sessionChildren.sockets).sort((ref1, ref2) => ref1.id - ref2.id);\n\n  const allSockets = resolvedInfo.sessionChildren.sockets.sort((ref1, ref2) => ref1.id - ref2.id);\n  const resultList = [];\n  let i = 0;\n\n  for (; i < allSockets.length; i++) {\n    if (allSockets[i].id >= startId) {\n      resultList.push(socketRefToMessage(allSockets[i]));\n\n      if (resultList.length >= maxResults) {\n        break;\n      }\n    }\n  }\n\n  callback(null, {\n    socket_ref: resultList,\n    end: i >= allSockets.length\n  });\n}\n\nfunction getChannelzHandlers() {\n  return {\n    GetChannel,\n    GetTopChannels,\n    GetServer,\n    GetServers,\n    GetSubchannel,\n    GetSocket,\n    GetServerSockets\n  };\n}\n\nexports.getChannelzHandlers = getChannelzHandlers;\nlet loadedChannelzDefinition = null;\n\nfunction getChannelzServiceDefinition() {\n  if (loadedChannelzDefinition) {\n    return loadedChannelzDefinition;\n  }\n  /* The purpose of this complexity is to avoid loading @grpc/proto-loader at\n   * runtime for users who will not use/enable channelz. */\n\n\n  const loaderLoadSync = require('@grpc/proto-loader').loadSync;\n\n  const loadedProto = loaderLoadSync('channelz.proto', {\n    keepCase: true,\n    longs: String,\n    enums: String,\n    defaults: true,\n    oneofs: true,\n    includeDirs: [`${__dirname}/../../proto`]\n  });\n  const channelzGrpcObject = make_client_1.loadPackageDefinition(loadedProto);\n  loadedChannelzDefinition = channelzGrpcObject.grpc.channelz.v1.Channelz.service;\n  return loadedChannelzDefinition;\n}\n\nexports.getChannelzServiceDefinition = getChannelzServiceDefinition;\n\nfunction setup() {\n  admin_1.registerAdminService(getChannelzServiceDefinition, getChannelzHandlers);\n}\n\nexports.setup = setup;","map":{"version":3,"mappings":"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","names":["channelRefToMessage","ref","channel_id","id","name","subchannelRefToMessage","subchannel_id","serverRefToMessage","server_id","socketRefToMessage","socket_id","TARGET_RETAINED_TRACES","ChannelzTrace","constructor","creationTimestamp","Date","addTrace","severity","description","child","timestamp","events","push","childChannel","kind","undefined","childSubchannel","length","slice","eventsLogged","getTraceMessage","creation_timestamp","dateToProtoTimestamp","num_events_logged","map","event","channel_ref","subchannel_ref","exports","ChannelzChildrenTracker","Map","refChild","trackedChild","channelChildren","get","_a","count","set","subchannelChildren","_b","socketChildren","_c","unrefChild","delete","getChildLists","channels","values","subchannels","sockets","ChannelzCallTracker","addCallStarted","callsStarted","lastCallStartedTimestamp","addCallSucceeded","callsSucceeded","addCallFailed","callsFailed","nextId","getNextId","servers","registerChannelzChannel","getInfo","channelzEnabled","registerChannelzSubchannel","registerChannelzServer","registerChannelzSocket","unregisterChannelzRef","parseIPv6Section","addressSection","numberValue","Number","parseInt","parseIPv6Chunk","addressChunk","bytePairs","split","section","result","concat","ipAddressStringToBuffer","ipAddress","net_1","Buffer","from","Uint8Array","segment","leftSection","rightSection","doubleColonIndex","indexOf","substring","leftBuffer","rightBuffer","middleBuffer","alloc","connectivityStateToMessage","state","connectivity_state_1","CONNECTING","IDLE","READY","SHUTDOWN","TRANSIENT_FAILURE","date","millisSinceEpoch","getTime","seconds","nanos","getChannelMessage","channelEntry","resolvedInfo","data","target","calls_started","callTracker","calls_succeeded","calls_failed","last_call_started_timestamp","trace","children","GetChannel","call","callback","channelId","request","constants_1","NOT_FOUND","channel","GetTopChannels","maxResults","max_results","resultList","i","start_channel_id","end","getServerMessage","serverEntry","listen_socket","listenerChildren","GetServer","serverId","server","GetServers","start_server_id","GetSubchannel","subchannelId","subchannelEntry","subchannelMessage","socket_ref","subchannel","subchannelAddressToAddressMessage","subchannelAddress","subchannel_address_1","address","tcpip_address","ip_address","host","port","uds_address","filename","path","GetSocket","socketId","socketEntry","securityMessage","security","model","tls","cipher_suite","cipherSuiteStandardName","standard_name","other_name","cipherSuiteOtherName","local_certificate","localCertificate","remote_certificate","remoteCertificate","_d","socketMessage","local","localAddress","remote","remoteAddress","remote_name","remoteName","_e","keep_alives_sent","keepAlivesSent","streams_started","streamsStarted","streams_succeeded","streamsSucceeded","streams_failed","streamsFailed","last_local_stream_created_timestamp","lastLocalStreamCreatedTimestamp","last_remote_stream_created_timestamp","lastRemoteStreamCreatedTimestamp","messages_received","messagesReceived","messages_sent","messagesSent","last_message_received_timestamp","lastMessageReceivedTimestamp","last_message_sent_timestamp","lastMessageSentTimestamp","local_flow_control_window","localFlowControlWindow","value","remote_flow_control_window","remoteFlowControlWindow","socket","GetServerSockets","startId","start_socket_id","allSockets","sessionChildren","sort","ref1","ref2","getChannelzHandlers","loadedChannelzDefinition","getChannelzServiceDefinition","loaderLoadSync","require","loadSync","loadedProto","keepCase","longs","String","enums","defaults","oneofs","includeDirs","__dirname","channelzGrpcObject","make_client_1","grpc","channelz","v1","Channelz","service","setup","admin_1"],"sources":["C:\\Users\\binel\\OneDrive\\Desktop\\Today\\Udemy\\iProfiler\\iProfiler\\iprofiler\\node_modules\\@grpc\\grpc-js\\src\\channelz.ts"],"sourcesContent":["/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { isIPv4, isIPv6 } from \"net\";\nimport { ConnectivityState } from \"./connectivity-state\";\nimport { Status } from \"./constants\";\nimport { Timestamp } from \"./generated/google/protobuf/Timestamp\";\nimport { Channel as ChannelMessage } from \"./generated/grpc/channelz/v1/Channel\";\nimport { ChannelConnectivityState__Output } from \"./generated/grpc/channelz/v1/ChannelConnectivityState\";\nimport { ChannelRef as ChannelRefMessage } from \"./generated/grpc/channelz/v1/ChannelRef\";\nimport { ChannelTrace } from \"./generated/grpc/channelz/v1/ChannelTrace\";\nimport { GetChannelRequest__Output } from \"./generated/grpc/channelz/v1/GetChannelRequest\";\nimport { GetChannelResponse } from \"./generated/grpc/channelz/v1/GetChannelResponse\";\nimport { sendUnaryData, ServerUnaryCall } from \"./server-call\";\nimport { ServerRef as ServerRefMessage } from \"./generated/grpc/channelz/v1/ServerRef\";\nimport { SocketRef as SocketRefMessage } from \"./generated/grpc/channelz/v1/SocketRef\";\nimport { isTcpSubchannelAddress, SubchannelAddress } from \"./subchannel-address\";\nimport { SubchannelRef as SubchannelRefMessage } from \"./generated/grpc/channelz/v1/SubchannelRef\";\nimport { GetServerRequest__Output } from \"./generated/grpc/channelz/v1/GetServerRequest\";\nimport { GetServerResponse } from \"./generated/grpc/channelz/v1/GetServerResponse\";\nimport { Server as ServerMessage } from \"./generated/grpc/channelz/v1/Server\";\nimport { GetServersRequest__Output } from \"./generated/grpc/channelz/v1/GetServersRequest\";\nimport { GetServersResponse } from \"./generated/grpc/channelz/v1/GetServersResponse\";\nimport { GetTopChannelsRequest__Output } from \"./generated/grpc/channelz/v1/GetTopChannelsRequest\";\nimport { GetTopChannelsResponse } from \"./generated/grpc/channelz/v1/GetTopChannelsResponse\";\nimport { GetSubchannelRequest__Output } from \"./generated/grpc/channelz/v1/GetSubchannelRequest\";\nimport { GetSubchannelResponse } from \"./generated/grpc/channelz/v1/GetSubchannelResponse\";\nimport { Subchannel as SubchannelMessage } from \"./generated/grpc/channelz/v1/Subchannel\";\nimport { GetSocketRequest__Output } from \"./generated/grpc/channelz/v1/GetSocketRequest\";\nimport { GetSocketResponse } from \"./generated/grpc/channelz/v1/GetSocketResponse\";\nimport { Socket as SocketMessage } from \"./generated/grpc/channelz/v1/Socket\";\nimport { Address } from \"./generated/grpc/channelz/v1/Address\";\nimport { Security } from \"./generated/grpc/channelz/v1/Security\";\nimport { GetServerSocketsRequest__Output } from \"./generated/grpc/channelz/v1/GetServerSocketsRequest\";\nimport { GetServerSocketsResponse } from \"./generated/grpc/channelz/v1/GetServerSocketsResponse\";\nimport { ChannelzDefinition, ChannelzHandlers } from \"./generated/grpc/channelz/v1/Channelz\";\nimport { ProtoGrpcType as ChannelzProtoGrpcType } from \"./generated/channelz\";\nimport type { loadSync } from '@grpc/proto-loader';\nimport { registerAdminService } from \"./admin\";\nimport { loadPackageDefinition } from \"./make-client\";\n\nexport type TraceSeverity = 'CT_UNKNOWN' | 'CT_INFO' | 'CT_WARNING' | 'CT_ERROR';\n\nexport interface ChannelRef {\n  kind: 'channel';\n  id: number;\n  name: string;\n}\n\nexport interface SubchannelRef {\n  kind: 'subchannel';\n  id: number;\n  name: string;\n}\n\nexport interface ServerRef {\n  kind: 'server';\n  id: number;\n}\n\nexport interface SocketRef {\n  kind: 'socket';\n  id: number;\n  name: string;\n}\n\nfunction channelRefToMessage(ref: ChannelRef): ChannelRefMessage {\n  return {\n    channel_id: ref.id,\n    name: ref.name\n  };\n}\n\nfunction subchannelRefToMessage(ref: SubchannelRef): SubchannelRefMessage {\n  return {\n    subchannel_id: ref.id,\n    name: ref.name\n  }\n}\n\nfunction serverRefToMessage(ref: ServerRef): ServerRefMessage {\n  return {\n    server_id: ref.id\n  }\n}\n\nfunction socketRefToMessage(ref: SocketRef): SocketRefMessage {\n  return {\n    socket_id: ref.id,\n    name: ref.name\n  }\n}\n\ninterface TraceEvent {\n  description: string;\n  severity: TraceSeverity;\n  timestamp: Date;\n  childChannel?: ChannelRef;\n  childSubchannel?: SubchannelRef;\n}\n\n/**\n * The loose upper bound on the number of events that should be retained in a\n * trace. This may be exceeded by up to a factor of 2. Arbitrarily chosen as a\n * number that should be large enough to contain the recent relevant\n * information, but small enough to not use excessive memory.\n */\nconst TARGET_RETAINED_TRACES = 32;\n\nexport class ChannelzTrace {\n  events: TraceEvent[] = [];\n  creationTimestamp: Date;\n  eventsLogged: number = 0;\n\n  constructor() {\n    this.creationTimestamp = new Date();\n  }\n\n  addTrace(severity: TraceSeverity, description: string, child?: ChannelRef | SubchannelRef) {\n    const timestamp = new Date();\n    this.events.push({\n      description: description,\n      severity: severity,\n      timestamp: timestamp,\n      childChannel: child?.kind === 'channel' ? child : undefined,\n      childSubchannel: child?.kind === 'subchannel' ? child : undefined\n    });\n    // Whenever the trace array gets too large, discard the first half\n    if (this.events.length >= TARGET_RETAINED_TRACES * 2) {\n      this.events = this.events.slice(TARGET_RETAINED_TRACES);\n    }\n    this.eventsLogged += 1;\n  }\n\n  getTraceMessage(): ChannelTrace {\n    return {\n      creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),\n      num_events_logged: this.eventsLogged,\n      events: this.events.map(event => {\n        return {\n          description: event.description,\n          severity: event.severity,\n          timestamp: dateToProtoTimestamp(event.timestamp),\n          channel_ref: event.childChannel ? channelRefToMessage(event.childChannel) : null,\n          subchannel_ref: event.childSubchannel ? subchannelRefToMessage(event.childSubchannel) : null\n        }\n      })\n    };\n  }\n}\n\nexport class ChannelzChildrenTracker {\n  private channelChildren: Map<number, {ref: ChannelRef, count: number}> = new Map<number, {ref: ChannelRef, count: number}>();\n  private subchannelChildren: Map<number, {ref: SubchannelRef, count: number}> = new Map<number, {ref: SubchannelRef, count: number}>();\n  private socketChildren: Map<number, {ref: SocketRef, count: number}> = new Map<number, {ref: SocketRef, count: number}>();\n\n  refChild(child: ChannelRef | SubchannelRef | SocketRef) {\n    switch (child.kind) {\n      case 'channel': {\n        let trackedChild = this.channelChildren.get(child.id) ?? {ref: child, count: 0};\n        trackedChild.count += 1;\n        this.channelChildren.set(child.id, trackedChild);\n        break;\n      }\n      case 'subchannel':{\n        let trackedChild = this.subchannelChildren.get(child.id) ?? {ref: child, count: 0};\n        trackedChild.count += 1;\n        this.subchannelChildren.set(child.id, trackedChild);\n        break;\n      }\n      case 'socket':{\n        let trackedChild = this.socketChildren.get(child.id) ?? {ref: child, count: 0};\n        trackedChild.count += 1;\n        this.socketChildren.set(child.id, trackedChild);\n        break;\n      }\n    }\n  }\n\n  unrefChild(child: ChannelRef | SubchannelRef | SocketRef) {\n    switch (child.kind) {\n      case 'channel': {\n        let trackedChild = this.channelChildren.get(child.id);\n        if (trackedChild !== undefined) {\n          trackedChild.count -= 1;\n          if (trackedChild.count === 0) {\n            this.channelChildren.delete(child.id);\n          } else {\n            this.channelChildren.set(child.id, trackedChild);\n          }\n        }\n        break;\n      }\n      case 'subchannel': {\n        let trackedChild = this.subchannelChildren.get(child.id);\n        if (trackedChild !== undefined) {\n          trackedChild.count -= 1;\n          if (trackedChild.count === 0) {\n            this.subchannelChildren.delete(child.id);\n          } else {\n            this.subchannelChildren.set(child.id, trackedChild);\n          }\n        }\n        break;\n      }\n      case 'socket': {\n        let trackedChild = this.socketChildren.get(child.id);\n        if (trackedChild !== undefined) {\n          trackedChild.count -= 1;\n          if (trackedChild.count === 0) {\n            this.socketChildren.delete(child.id);\n          } else {\n            this.socketChildren.set(child.id, trackedChild);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  getChildLists(): ChannelzChildren {\n    const channels: ChannelRef[] = [];\n    for (const {ref} of this.channelChildren.values()) {\n      channels.push(ref);\n    }\n    const subchannels: SubchannelRef[] = [];\n    for (const {ref} of this.subchannelChildren.values()) {\n      subchannels.push(ref);\n    }\n    const sockets: SocketRef[] = [];\n    for (const {ref} of this.socketChildren.values()) {\n      sockets.push(ref);\n    }\n    return {channels, subchannels, sockets};\n  }\n}\n\nexport class ChannelzCallTracker {\n  callsStarted: number = 0;\n  callsSucceeded: number = 0;\n  callsFailed: number = 0;\n  lastCallStartedTimestamp: Date | null = null;\n\n  addCallStarted() {\n    this.callsStarted += 1;\n    this.lastCallStartedTimestamp = new Date();\n  }\n  addCallSucceeded() {\n    this.callsSucceeded += 1;\n  }\n  addCallFailed() {\n    this.callsFailed += 1;\n  }\n}\n\nexport interface ChannelzChildren {\n  channels: ChannelRef[];\n  subchannels: SubchannelRef[];\n  sockets: SocketRef[];\n}\n\nexport interface ChannelInfo {\n  target: string;\n  state: ConnectivityState;\n  trace: ChannelzTrace;\n  callTracker: ChannelzCallTracker;\n  children: ChannelzChildren;\n}\n\nexport interface SubchannelInfo extends ChannelInfo {}\n\nexport interface ServerInfo {\n  trace: ChannelzTrace;\n  callTracker: ChannelzCallTracker;\n  listenerChildren: ChannelzChildren;\n  sessionChildren: ChannelzChildren;\n}\n\nexport interface TlsInfo {\n  cipherSuiteStandardName: string | null;\n  cipherSuiteOtherName: string | null;\n  localCertificate: Buffer | null;\n  remoteCertificate: Buffer | null;\n}\n\nexport interface SocketInfo {\n  localAddress: SubchannelAddress | null;\n  remoteAddress: SubchannelAddress | null;\n  security: TlsInfo | null;\n  remoteName: string | null;\n  streamsStarted: number;\n  streamsSucceeded: number;\n  streamsFailed: number;\n  messagesSent: number;\n  messagesReceived: number;\n  keepAlivesSent: number;\n  lastLocalStreamCreatedTimestamp: Date | null;\n  lastRemoteStreamCreatedTimestamp: Date | null;\n  lastMessageSentTimestamp: Date | null;\n  lastMessageReceivedTimestamp: Date | null;\n  localFlowControlWindow: number | null;\n  remoteFlowControlWindow: number | null;\n}\n\ninterface ChannelEntry {\n  ref: ChannelRef;\n  getInfo(): ChannelInfo;\n}\n\ninterface SubchannelEntry {\n  ref: SubchannelRef;\n  getInfo(): SubchannelInfo;\n}\n\ninterface ServerEntry {\n  ref: ServerRef;\n  getInfo(): ServerInfo;\n}\n\ninterface SocketEntry {\n  ref: SocketRef;\n  getInfo(): SocketInfo;\n}\n\nlet nextId = 1;\n\nfunction getNextId(): number {\n  return nextId++;\n}\n\nconst channels: (ChannelEntry | undefined)[] = [];\nconst subchannels: (SubchannelEntry | undefined)[] = [];\nconst servers: (ServerEntry | undefined)[] = [];\nconst sockets: (SocketEntry | undefined)[] = [];\n\nexport function registerChannelzChannel(name: string, getInfo: () => ChannelInfo, channelzEnabled: boolean): ChannelRef {\n  const id = getNextId();\n  const ref: ChannelRef = {id, name, kind: 'channel'};\n  if (channelzEnabled) {\n    channels[id] = { ref, getInfo };\n  }\n  return ref;\n}\n\nexport function registerChannelzSubchannel(name: string, getInfo:() => SubchannelInfo, channelzEnabled: boolean): SubchannelRef {\n  const id = getNextId();\n  const ref: SubchannelRef = {id, name, kind: 'subchannel'};\n  if (channelzEnabled) {\n    subchannels[id] = { ref, getInfo };\n  }\n  return ref;\n}\n\nexport function registerChannelzServer(getInfo: () => ServerInfo, channelzEnabled: boolean): ServerRef {\n  const id = getNextId();\n  const ref: ServerRef = {id, kind: 'server'};\n  if (channelzEnabled) {\n    servers[id] = { ref, getInfo };\n  }\n  return ref;\n}\n\nexport function registerChannelzSocket(name: string, getInfo: () => SocketInfo, channelzEnabled: boolean): SocketRef {\n  const id = getNextId();\n  const ref: SocketRef = {id, name, kind: 'socket'};\n  if (channelzEnabled) {\n    sockets[id] = { ref, getInfo};\n  }\n  return ref;\n}\n\nexport function unregisterChannelzRef(ref: ChannelRef | SubchannelRef | ServerRef | SocketRef) {\n  switch (ref.kind) {\n    case 'channel':\n      delete channels[ref.id];\n      return;\n    case 'subchannel':\n      delete subchannels[ref.id];\n      return;\n    case 'server':\n      delete servers[ref.id];\n      return;\n    case 'socket':\n      delete sockets[ref.id];\n      return;\n  }\n}\n\n/**\n * Parse a single section of an IPv6 address as two bytes\n * @param addressSection A hexadecimal string of length up to 4\n * @returns The pair of bytes representing this address section\n */\nfunction parseIPv6Section(addressSection: string): [number, number] {\n  const numberValue = Number.parseInt(addressSection, 16);\n  return [numberValue / 256 | 0, numberValue % 256];\n}\n\n/**\n * Parse a chunk of an IPv6 address string to some number of bytes\n * @param addressChunk Some number of segments of up to 4 hexadecimal\n *   characters each, joined by colons.\n * @returns The list of bytes representing this address chunk\n */\nfunction parseIPv6Chunk(addressChunk: string): number[] {\n  if (addressChunk === '') {\n    return [];\n  }\n  const bytePairs = addressChunk.split(':').map(section => parseIPv6Section(section));\n  const result: number[] = [];\n  return result.concat(...bytePairs);\n}\n\n/**\n * Converts an IPv4 or IPv6 address from string representation to binary\n * representation\n * @param ipAddress an IP address in standard IPv4 or IPv6 text format\n * @returns \n */\nfunction ipAddressStringToBuffer(ipAddress: string): Buffer | null {\n  if (isIPv4(ipAddress)) {\n    return Buffer.from(Uint8Array.from(ipAddress.split('.').map(segment => Number.parseInt(segment))));\n  } else if (isIPv6(ipAddress)) {\n    let leftSection: string;\n    let rightSection: string;\n    const doubleColonIndex = ipAddress.indexOf('::');\n    if (doubleColonIndex === -1) {\n      leftSection = ipAddress;\n      rightSection = '';\n    } else {\n      leftSection = ipAddress.substring(0, doubleColonIndex);\n      rightSection = ipAddress.substring(doubleColonIndex + 2);\n    }\n    const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));\n    const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));\n    const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);\n    return Buffer.concat([leftBuffer, middleBuffer, rightBuffer]);\n  } else {\n    return null;\n  }\n}\n\nfunction connectivityStateToMessage(state: ConnectivityState): ChannelConnectivityState__Output {\n  switch (state) {\n    case ConnectivityState.CONNECTING:\n      return {\n        state: 'CONNECTING'\n      };\n    case ConnectivityState.IDLE:\n      return {\n        state: 'IDLE'\n      };\n    case ConnectivityState.READY:\n      return {\n        state: 'READY'\n      };\n    case ConnectivityState.SHUTDOWN:\n      return {\n        state: 'SHUTDOWN'\n      };\n    case ConnectivityState.TRANSIENT_FAILURE:\n      return {\n        state: 'TRANSIENT_FAILURE'\n      };\n    default:\n      return {\n        state: 'UNKNOWN'\n      };\n  }\n}\n\nfunction dateToProtoTimestamp(date?: Date | null): Timestamp | null {\n  if (!date) {\n    return null;\n  }\n  const millisSinceEpoch = date.getTime();\n  return {\n    seconds: (millisSinceEpoch / 1000) | 0,\n    nanos: (millisSinceEpoch % 1000) * 1_000_000\n  }\n}\n\nfunction getChannelMessage(channelEntry: ChannelEntry): ChannelMessage {\n  const resolvedInfo = channelEntry.getInfo();\n  return {\n    ref: channelRefToMessage(channelEntry.ref),\n    data: {\n      target: resolvedInfo.target,\n      state: connectivityStateToMessage(resolvedInfo.state),\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n      trace: resolvedInfo.trace.getTraceMessage()\n    },\n    channel_ref: resolvedInfo.children.channels.map(ref => channelRefToMessage(ref)),\n    subchannel_ref: resolvedInfo.children.subchannels.map(ref => subchannelRefToMessage(ref))\n  };\n}\n\nfunction GetChannel(call: ServerUnaryCall<GetChannelRequest__Output, GetChannelResponse>, callback: sendUnaryData<GetChannelResponse>): void {\n  const channelId = Number.parseInt(call.request.channel_id);\n  const channelEntry = channels[channelId];\n  if (channelEntry === undefined) {\n    callback({\n      'code': Status.NOT_FOUND,\n      'details': 'No channel data found for id ' + channelId\n    });\n    return;\n  }\n  callback(null, {channel: getChannelMessage(channelEntry)});\n}\n\nfunction GetTopChannels(call: ServerUnaryCall<GetTopChannelsRequest__Output, GetTopChannelsResponse>, callback: sendUnaryData<GetTopChannelsResponse>): void {\n  const maxResults = Number.parseInt(call.request.max_results);\n  const resultList: ChannelMessage[] = [];\n  let i = Number.parseInt(call.request.start_channel_id);\n  for (; i < channels.length; i++) {\n    const channelEntry = channels[i];\n    if (channelEntry === undefined) {\n      continue;\n    }\n    resultList.push(getChannelMessage(channelEntry));\n    if (resultList.length >= maxResults) {\n      break;\n    }\n  }\n  callback(null, {\n    channel: resultList,\n    end: i >= servers.length\n  });\n}\n\nfunction getServerMessage(serverEntry: ServerEntry): ServerMessage {\n  const resolvedInfo = serverEntry.getInfo();\n  return {\n    ref: serverRefToMessage(serverEntry.ref),\n    data: {\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n      trace: resolvedInfo.trace.getTraceMessage()\n    },\n    listen_socket: resolvedInfo.listenerChildren.sockets.map(ref => socketRefToMessage(ref))\n  };\n}\n\nfunction GetServer(call: ServerUnaryCall<GetServerRequest__Output, GetServerResponse>, callback: sendUnaryData<GetServerResponse>): void {\n  const serverId = Number.parseInt(call.request.server_id);\n  const serverEntry = servers[serverId];\n  if (serverEntry === undefined) {\n    callback({\n      'code': Status.NOT_FOUND,\n      'details': 'No server data found for id ' + serverId\n    });\n    return;\n  }\n  callback(null, {server: getServerMessage(serverEntry)});\n}\n\nfunction GetServers(call: ServerUnaryCall<GetServersRequest__Output, GetServersResponse>, callback: sendUnaryData<GetServersResponse>): void {\n  const maxResults = Number.parseInt(call.request.max_results);\n  const resultList: ServerMessage[] = [];\n  let i = Number.parseInt(call.request.start_server_id);\n  for (; i < servers.length; i++) {\n    const serverEntry = servers[i];\n    if (serverEntry === undefined) {\n      continue;\n    }\n    resultList.push(getServerMessage(serverEntry));\n    if (resultList.length >= maxResults) {\n      break;\n    }\n  }\n  callback(null, {\n    server: resultList,\n    end: i >= servers.length\n  });\n}\n\nfunction GetSubchannel(call: ServerUnaryCall<GetSubchannelRequest__Output, GetSubchannelResponse>, callback: sendUnaryData<GetSubchannelResponse>): void {\n  const subchannelId = Number.parseInt(call.request.subchannel_id);\n  const subchannelEntry = subchannels[subchannelId];\n  if (subchannelEntry === undefined) {\n    callback({\n      'code': Status.NOT_FOUND,\n      'details': 'No subchannel data found for id ' + subchannelId\n    });\n    return;\n  }\n  const resolvedInfo = subchannelEntry.getInfo();\n  const subchannelMessage: SubchannelMessage = {\n    ref: subchannelRefToMessage(subchannelEntry.ref),\n    data: {\n      target: resolvedInfo.target,\n      state: connectivityStateToMessage(resolvedInfo.state),\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n      trace: resolvedInfo.trace.getTraceMessage()\n    },\n    socket_ref: resolvedInfo.children.sockets.map(ref => socketRefToMessage(ref))\n  };\n  callback(null, {subchannel: subchannelMessage});\n}\n\nfunction subchannelAddressToAddressMessage(subchannelAddress: SubchannelAddress): Address {\n  if (isTcpSubchannelAddress(subchannelAddress)) {\n    return {\n      address: 'tcpip_address',\n      tcpip_address: {\n        ip_address: ipAddressStringToBuffer(subchannelAddress.host) ?? undefined,\n        port: subchannelAddress.port\n      }\n    };\n  } else {\n    return {\n      address: 'uds_address',\n      uds_address: {\n        filename: subchannelAddress.path\n      }\n    };\n  }\n}\n\nfunction GetSocket(call: ServerUnaryCall<GetSocketRequest__Output, GetSocketResponse>, callback: sendUnaryData<GetSocketResponse>): void {\n  const socketId = Number.parseInt(call.request.socket_id);\n  const socketEntry = sockets[socketId];\n  if (socketEntry === undefined) {\n    callback({\n      'code': Status.NOT_FOUND,\n      'details': 'No socket data found for id ' + socketId\n    });\n    return;\n  }\n  const resolvedInfo = socketEntry.getInfo();\n  const securityMessage: Security | null = resolvedInfo.security ? {\n    model: 'tls',\n    tls: {\n      cipher_suite: resolvedInfo.security.cipherSuiteStandardName ? 'standard_name' : 'other_name',\n      standard_name: resolvedInfo.security.cipherSuiteStandardName ?? undefined,\n      other_name: resolvedInfo.security.cipherSuiteOtherName ?? undefined,\n      local_certificate: resolvedInfo.security.localCertificate ?? undefined,\n      remote_certificate: resolvedInfo.security.remoteCertificate ?? undefined\n    }\n  } : null;\n  const socketMessage: SocketMessage = {\n    ref: socketRefToMessage(socketEntry.ref),\n    local: resolvedInfo.localAddress ? subchannelAddressToAddressMessage(resolvedInfo.localAddress) : null,\n    remote: resolvedInfo.remoteAddress ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress) : null,\n    remote_name: resolvedInfo.remoteName ?? undefined,\n    security: securityMessage,\n    data: {\n      keep_alives_sent: resolvedInfo.keepAlivesSent,\n      streams_started: resolvedInfo.streamsStarted,\n      streams_succeeded: resolvedInfo.streamsSucceeded,\n      streams_failed: resolvedInfo.streamsFailed,\n      last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),\n      last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),\n      messages_received: resolvedInfo.messagesReceived,\n      messages_sent: resolvedInfo.messagesSent,\n      last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),\n      last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),\n      local_flow_control_window: resolvedInfo.localFlowControlWindow ? { value: resolvedInfo.localFlowControlWindow } : null,\n      remote_flow_control_window: resolvedInfo.remoteFlowControlWindow ? { value: resolvedInfo.remoteFlowControlWindow } : null,\n    }\n  };\n  callback(null, {socket: socketMessage});\n}\n\nfunction GetServerSockets(call: ServerUnaryCall<GetServerSocketsRequest__Output, GetServerSocketsResponse>, callback: sendUnaryData<GetServerSocketsResponse>): void {\n  const serverId = Number.parseInt(call.request.server_id);\n  const serverEntry = servers[serverId];\n  if (serverEntry === undefined) {\n    callback({\n      'code': Status.NOT_FOUND,\n      'details': 'No server data found for id ' + serverId\n    });\n    return;\n  }\n  const startId = Number.parseInt(call.request.start_socket_id);\n  const maxResults = Number.parseInt(call.request.max_results);\n  const resolvedInfo = serverEntry.getInfo();\n  // If we wanted to include listener sockets in the result, this line would\n  // instead say\n  // const allSockets = resolvedInfo.listenerChildren.sockets.concat(resolvedInfo.sessionChildren.sockets).sort((ref1, ref2) => ref1.id - ref2.id);\n  const allSockets = resolvedInfo.sessionChildren.sockets.sort((ref1, ref2) => ref1.id - ref2.id);\n  const resultList: SocketRefMessage[] = [];\n  let i = 0;\n  for (; i < allSockets.length; i++) {\n    if (allSockets[i].id >= startId) {\n      resultList.push(socketRefToMessage(allSockets[i]));\n      if (resultList.length >= maxResults) {\n        break;\n      }\n    }\n  }\n  callback(null, {\n    socket_ref: resultList,\n    end: i >= allSockets.length\n  });\n}\n\nexport function getChannelzHandlers(): ChannelzHandlers {\n  return {\n    GetChannel,\n    GetTopChannels,\n    GetServer,\n    GetServers,\n    GetSubchannel,\n    GetSocket,\n    GetServerSockets\n  };\n}\n\nlet loadedChannelzDefinition: ChannelzDefinition | null = null;\n\nexport function getChannelzServiceDefinition(): ChannelzDefinition {\n  if (loadedChannelzDefinition) {\n    return loadedChannelzDefinition;\n  }\n  /* The purpose of this complexity is to avoid loading @grpc/proto-loader at\n   * runtime for users who will not use/enable channelz. */\n  const loaderLoadSync = require('@grpc/proto-loader').loadSync as typeof loadSync;\n  const loadedProto = loaderLoadSync('channelz.proto', {\n    keepCase: true,\n    longs: String,\n    enums: String,\n    defaults: true,\n    oneofs: true,\n    includeDirs: [\n      `${__dirname}/../../proto`\n    ]\n  });\n  const channelzGrpcObject = loadPackageDefinition(loadedProto) as unknown as ChannelzProtoGrpcType;\n  loadedChannelzDefinition = channelzGrpcObject.grpc.channelz.v1.Channelz.service;\n  return loadedChannelzDefinition;\n}\n\nexport function setup() {\n  registerAdminService(getChannelzServiceDefinition, getChannelzHandlers);\n}"]},"metadata":{},"sourceType":"script"}