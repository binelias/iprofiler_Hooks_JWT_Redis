{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChannelImplementation = void 0;\n\nconst call_stream_1 = require(\"./call-stream\");\n\nconst channel_credentials_1 = require(\"./channel-credentials\");\n\nconst resolving_load_balancer_1 = require(\"./resolving-load-balancer\");\n\nconst subchannel_pool_1 = require(\"./subchannel-pool\");\n\nconst picker_1 = require(\"./picker\");\n\nconst constants_1 = require(\"./constants\");\n\nconst filter_stack_1 = require(\"./filter-stack\");\n\nconst call_credentials_filter_1 = require(\"./call-credentials-filter\");\n\nconst deadline_filter_1 = require(\"./deadline-filter\");\n\nconst compression_filter_1 = require(\"./compression-filter\");\n\nconst resolver_1 = require(\"./resolver\");\n\nconst logging_1 = require(\"./logging\");\n\nconst max_message_size_filter_1 = require(\"./max-message-size-filter\");\n\nconst http_proxy_1 = require(\"./http_proxy\");\n\nconst uri_parser_1 = require(\"./uri-parser\");\n\nconst connectivity_state_1 = require(\"./connectivity-state\");\n\nconst channelz_1 = require(\"./channelz\");\n/**\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\n */\n\n\nconst MAX_TIMEOUT_TIME = 2147483647;\nlet nextCallNumber = 0;\n\nfunction getNewCallNumber() {\n  const callNumber = nextCallNumber;\n  nextCallNumber += 1;\n\n  if (nextCallNumber >= Number.MAX_SAFE_INTEGER) {\n    nextCallNumber = 0;\n  }\n\n  return callNumber;\n}\n\nclass ChannelImplementation {\n  constructor(target, credentials, options) {\n    var _a, _b, _c, _d;\n\n    this.credentials = credentials;\n    this.options = options;\n    this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n    this.currentPicker = new picker_1.UnavailablePicker();\n    /**\n     * Calls queued up to get a call config. Should only be populated before the\n     * first time the resolver returns a result, which includes the ConfigSelector.\n     */\n\n    this.configSelectionQueue = [];\n    this.pickQueue = [];\n    this.connectivityStateWatchers = [];\n    this.configSelector = null;\n    /**\n     * This is the error from the name resolver if it failed most recently. It\n     * is only used to end calls that start while there is no config selector\n     * and the name resolver is in backoff, so it should be nulled if\n     * configSelector becomes set or the channel state becomes anything other\n     * than TRANSIENT_FAILURE.\n     */\n\n    this.currentResolutionError = null; // Channelz info\n\n    this.channelzEnabled = true;\n    this.callTracker = new channelz_1.ChannelzCallTracker();\n    this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n\n    if (typeof target !== 'string') {\n      throw new TypeError('Channel target must be a string');\n    }\n\n    if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\n      throw new TypeError('Channel credentials must be a ChannelCredentials object');\n    }\n\n    if (options) {\n      if (typeof options !== 'object') {\n        throw new TypeError('Channel options must be an object');\n      }\n    }\n\n    this.originalTarget = target;\n    const originalTargetUri = uri_parser_1.parseUri(target);\n\n    if (originalTargetUri === null) {\n      throw new Error(`Could not parse target name \"${target}\"`);\n    }\n    /* This ensures that the target has a scheme that is registered with the\n     * resolver */\n\n\n    const defaultSchemeMapResult = resolver_1.mapUriDefaultScheme(originalTargetUri);\n\n    if (defaultSchemeMapResult === null) {\n      throw new Error(`Could not find a default scheme for target name \"${target}\"`);\n    }\n\n    this.callRefTimer = setInterval(() => {}, MAX_TIMEOUT_TIME);\n    (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n\n    if (this.options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n\n    this.channelzTrace = new channelz_1.ChannelzTrace();\n    this.channelzRef = channelz_1.registerChannelzChannel(target, () => this.getChannelzInfo(), this.channelzEnabled);\n\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Channel created');\n    }\n\n    if (this.options['grpc.default_authority']) {\n      this.defaultAuthority = this.options['grpc.default_authority'];\n    } else {\n      this.defaultAuthority = resolver_1.getDefaultAuthority(defaultSchemeMapResult);\n    }\n\n    const proxyMapResult = http_proxy_1.mapProxyName(defaultSchemeMapResult, options);\n    this.target = proxyMapResult.target;\n    this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\n    /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n     * the grpc.use_local_subchannel_pool channel option means. */\n\n    this.subchannelPool = subchannel_pool_1.getSubchannelPool(((_c = options['grpc.use_local_subchannel_pool']) !== null && _c !== void 0 ? _c : 0) === 0);\n    const channelControlHelper = {\n      createSubchannel: (subchannelAddress, subchannelArgs) => {\n        const subchannel = this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);\n\n        if (this.channelzEnabled) {\n          this.channelzTrace.addTrace('CT_INFO', 'Created subchannel or used existing subchannel', subchannel.getChannelzRef());\n        }\n\n        return subchannel;\n      },\n      updateState: (connectivityState, picker) => {\n        this.currentPicker = picker;\n        const queueCopy = this.pickQueue.slice();\n        this.pickQueue = [];\n        this.callRefTimerUnref();\n\n        for (const {\n          callStream,\n          callMetadata,\n          callConfig,\n          dynamicFilters\n        } of queueCopy) {\n          this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n        }\n\n        this.updateState(connectivityState);\n      },\n      requestReresolution: () => {\n        // This should never be called.\n        throw new Error('Resolving load balancer should never call requestReresolution');\n      },\n      addChannelzChild: child => {\n        if (this.channelzEnabled) {\n          this.childrenTracker.refChild(child);\n        }\n      },\n      removeChannelzChild: child => {\n        if (this.channelzEnabled) {\n          this.childrenTracker.unrefChild(child);\n        }\n      }\n    };\n    this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options, configSelector => {\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Address resolution succeeded');\n      }\n\n      this.configSelector = configSelector;\n      this.currentResolutionError = null;\n      /* We process the queue asynchronously to ensure that the corresponding\n       * load balancer update has completed. */\n\n      process.nextTick(() => {\n        const localQueue = this.configSelectionQueue;\n        this.configSelectionQueue = [];\n        this.callRefTimerUnref();\n\n        for (const {\n          callStream,\n          callMetadata\n        } of localQueue) {\n          this.tryGetConfig(callStream, callMetadata);\n        }\n\n        this.configSelectionQueue = [];\n      });\n    }, status => {\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_WARNING', 'Address resolution failed with code ' + status.code + ' and details \"' + status.details + '\"');\n      }\n\n      if (this.configSelectionQueue.length > 0) {\n        this.trace('Name resolution failed with calls queued for config selection');\n      }\n\n      if (this.configSelector === null) {\n        this.currentResolutionError = status;\n      }\n\n      const localQueue = this.configSelectionQueue;\n      this.configSelectionQueue = [];\n      this.callRefTimerUnref();\n\n      for (const {\n        callStream,\n        callMetadata\n      } of localQueue) {\n        if (callMetadata.getOptions().waitForReady) {\n          this.callRefTimerRef();\n          this.configSelectionQueue.push({\n            callStream,\n            callMetadata\n          });\n        } else {\n          callStream.cancelWithStatus(status.code, status.details);\n        }\n      }\n    });\n    this.filterStackFactory = new filter_stack_1.FilterStackFactory([new call_credentials_filter_1.CallCredentialsFilterFactory(this), new deadline_filter_1.DeadlineFilterFactory(this), new max_message_size_filter_1.MaxMessageSizeFilterFactory(this.options), new compression_filter_1.CompressionFilterFactory(this, this.options)]);\n    this.trace('Channel constructed with options ' + JSON.stringify(options, undefined, 2));\n    const error = new Error();\n    logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel_stacktrace', '(' + this.channelzRef.id + ') ' + 'Channel constructed \\n' + ((_d = error.stack) === null || _d === void 0 ? void 0 : _d.substring(error.stack.indexOf('\\n') + 1)));\n  }\n\n  getChannelzInfo() {\n    return {\n      target: this.originalTarget,\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists()\n    };\n  }\n\n  trace(text, verbosityOverride) {\n    logging_1.trace(verbosityOverride !== null && verbosityOverride !== void 0 ? verbosityOverride : constants_1.LogVerbosity.DEBUG, 'channel', '(' + this.channelzRef.id + ') ' + uri_parser_1.uriToString(this.target) + ' ' + text);\n  }\n\n  callRefTimerRef() {\n    var _a, _b, _c, _d; // If the hasRef function does not exist, always run the code\n\n\n    if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n      this.trace('callRefTimer.ref | configSelectionQueue.length=' + this.configSelectionQueue.length + ' pickQueue.length=' + this.pickQueue.length);\n      (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);\n    }\n  }\n\n  callRefTimerUnref() {\n    var _a, _b; // If the hasRef function does not exist, always run the code\n\n\n    if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {\n      this.trace('callRefTimer.unref | configSelectionQueue.length=' + this.configSelectionQueue.length + ' pickQueue.length=' + this.pickQueue.length);\n      (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n  }\n\n  pushPick(callStream, callMetadata, callConfig, dynamicFilters) {\n    this.pickQueue.push({\n      callStream,\n      callMetadata,\n      callConfig,\n      dynamicFilters\n    });\n    this.callRefTimerRef();\n  }\n  /**\n   * Check the picker output for the given call and corresponding metadata,\n   * and take any relevant actions. Should not be called while iterating\n   * over pickQueue.\n   * @param callStream\n   * @param callMetadata\n   */\n\n\n  tryPick(callStream, callMetadata, callConfig, dynamicFilters) {\n    var _a, _b;\n\n    const pickResult = this.currentPicker.pick({\n      metadata: callMetadata,\n      extraPickInfo: callConfig.pickInformation\n    });\n    const subchannelString = pickResult.subchannel ? '(' + pickResult.subchannel.getChannelzRef().id + ') ' + pickResult.subchannel.getAddress() : '' + pickResult.subchannel;\n    this.trace('Pick result for call [' + callStream.getCallNumber() + ']: ' + picker_1.PickResultType[pickResult.pickResultType] + ' subchannel: ' + subchannelString + ' status: ' + ((_a = pickResult.status) === null || _a === void 0 ? void 0 : _a.code) + ' ' + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.details));\n\n    switch (pickResult.pickResultType) {\n      case picker_1.PickResultType.COMPLETE:\n        if (pickResult.subchannel === null) {\n          callStream.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Request dropped by load balancing policy'); // End the call with an error\n        } else {\n          /* If the subchannel is not in the READY state, that indicates a bug\n           * somewhere in the load balancer or picker. So, we log an error and\n           * queue the pick to be tried again later. */\n          if (pickResult.subchannel.getConnectivityState() !== connectivity_state_1.ConnectivityState.READY) {\n            logging_1.log(constants_1.LogVerbosity.ERROR, 'Error: COMPLETE pick result subchannel ' + subchannelString + ' has state ' + connectivity_state_1.ConnectivityState[pickResult.subchannel.getConnectivityState()]);\n            this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n            break;\n          }\n          /* We need to clone the callMetadata here because the transparent\n           * retry code in the promise resolution handler use the same\n           * callMetadata object, so it needs to stay unmodified */\n\n\n          callStream.filterStack.sendMetadata(Promise.resolve(callMetadata.clone())).then(finalMetadata => {\n            var _a, _b, _c;\n\n            const subchannelState = pickResult.subchannel.getConnectivityState();\n\n            if (subchannelState === connectivity_state_1.ConnectivityState.READY) {\n              try {\n                const pickExtraFilters = pickResult.extraFilterFactories.map(factory => factory.createFilter(callStream));\n                (_a = pickResult.subchannel) === null || _a === void 0 ? void 0 : _a.getRealSubchannel().startCallStream(finalMetadata, callStream, [...dynamicFilters, ...pickExtraFilters]);\n                /* If we reach this point, the call stream has started\n                 * successfully */\n\n                (_b = callConfig.onCommitted) === null || _b === void 0 ? void 0 : _b.call(callConfig);\n                (_c = pickResult.onCallStarted) === null || _c === void 0 ? void 0 : _c.call(pickResult);\n              } catch (error) {\n                const errorCode = error.code;\n\n                if (errorCode === 'ERR_HTTP2_GOAWAY_SESSION' || errorCode === 'ERR_HTTP2_INVALID_SESSION') {\n                  /* An error here indicates that something went wrong with\n                   * the picked subchannel's http2 stream right before we\n                   * tried to start the stream. We are handling a promise\n                   * result here, so this is asynchronous with respect to the\n                   * original tryPick call, so calling it again is not\n                   * recursive. We call tryPick immediately instead of\n                   * queueing this pick again because handling the queue is\n                   * triggered by state changes, and we want to immediately\n                   * check if the state has already changed since the\n                   * previous tryPick call. We do this instead of cancelling\n                   * the stream because the correct behavior may be\n                   * re-queueing instead, based on the logic in the rest of\n                   * tryPick */\n                  this.trace('Failed to start call on picked subchannel ' + subchannelString + ' with error ' + error.message + '. Retrying pick', constants_1.LogVerbosity.INFO);\n                  this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n                } else {\n                  this.trace('Failed to start call on picked subchanel ' + subchannelString + ' with error ' + error.message + '. Ending call', constants_1.LogVerbosity.INFO);\n                  callStream.cancelWithStatus(constants_1.Status.INTERNAL, `Failed to start HTTP/2 stream with error: ${error.message}`);\n                }\n              }\n            } else {\n              /* The logic for doing this here is the same as in the catch\n               * block above */\n              this.trace('Picked subchannel ' + subchannelString + ' has state ' + connectivity_state_1.ConnectivityState[subchannelState] + ' after metadata filters. Retrying pick', constants_1.LogVerbosity.INFO);\n              this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n            }\n          }, error => {\n            // We assume the error code isn't 0 (Status.OK)\n            callStream.cancelWithStatus(typeof error.code === 'number' ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);\n          });\n        }\n\n        break;\n\n      case picker_1.PickResultType.QUEUE:\n        this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n        break;\n\n      case picker_1.PickResultType.TRANSIENT_FAILURE:\n        if (callMetadata.getOptions().waitForReady) {\n          this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n        } else {\n          callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);\n        }\n\n        break;\n\n      case picker_1.PickResultType.DROP:\n        callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);\n        break;\n\n      default:\n        throw new Error(`Invalid state: unknown pickResultType ${pickResult.pickResultType}`);\n    }\n  }\n\n  removeConnectivityStateWatcher(watcherObject) {\n    const watcherIndex = this.connectivityStateWatchers.findIndex(value => value === watcherObject);\n\n    if (watcherIndex >= 0) {\n      this.connectivityStateWatchers.splice(watcherIndex, 1);\n    }\n  }\n\n  updateState(newState) {\n    logging_1.trace(constants_1.LogVerbosity.DEBUG, 'connectivity_state', '(' + this.channelzRef.id + ') ' + uri_parser_1.uriToString(this.target) + ' ' + connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    }\n\n    this.connectivityState = newState;\n    const watchersCopy = this.connectivityStateWatchers.slice();\n\n    for (const watcherObject of watchersCopy) {\n      if (newState !== watcherObject.currentState) {\n        if (watcherObject.timer) {\n          clearTimeout(watcherObject.timer);\n        }\n\n        this.removeConnectivityStateWatcher(watcherObject);\n        watcherObject.callback();\n      }\n    }\n\n    if (newState !== connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n      this.currentResolutionError = null;\n    }\n  }\n\n  tryGetConfig(stream, metadata) {\n    if (stream.getStatus() !== null) {\n      /* If the stream has a status, it has already finished and we don't need\n       * to take any more actions on it. */\n      return;\n    }\n\n    if (this.configSelector === null) {\n      /* This branch will only be taken at the beginning of the channel's life,\n       * before the resolver ever returns a result. So, the\n       * ResolvingLoadBalancer may be idle and if so it needs to be kicked\n       * because it now has a pending request. */\n      this.resolvingLoadBalancer.exitIdle();\n\n      if (this.currentResolutionError && !metadata.getOptions().waitForReady) {\n        stream.cancelWithStatus(this.currentResolutionError.code, this.currentResolutionError.details);\n      } else {\n        this.configSelectionQueue.push({\n          callStream: stream,\n          callMetadata: metadata\n        });\n        this.callRefTimerRef();\n      }\n    } else {\n      const callConfig = this.configSelector(stream.getMethod(), metadata);\n\n      if (callConfig.status === constants_1.Status.OK) {\n        if (callConfig.methodConfig.timeout) {\n          const deadline = new Date();\n          deadline.setSeconds(deadline.getSeconds() + callConfig.methodConfig.timeout.seconds);\n          deadline.setMilliseconds(deadline.getMilliseconds() + callConfig.methodConfig.timeout.nanos / 1000000);\n          stream.setConfigDeadline(deadline); // Refreshing the filters makes the deadline filter pick up the new deadline\n\n          stream.filterStack.refresh();\n        }\n\n        if (callConfig.dynamicFilterFactories.length > 0) {\n          /* These dynamicFilters are the mechanism for implementing gRFC A39:\n           * https://github.com/grpc/proposal/blob/master/A39-xds-http-filters.md\n           * We run them here instead of with the rest of the filters because\n           * that spec says \"the xDS HTTP filters will run in between name\n           * resolution and load balancing\".\n           *\n           * We use the filter stack here to simplify the multi-filter async\n           * waterfall logic, but we pass along the underlying list of filters\n           * to avoid having nested filter stacks when combining it with the\n           * original filter stack. We do not pass along the original filter\n           * factory list because these filters may need to persist data\n           * between sending headers and other operations. */\n          const dynamicFilterStackFactory = new filter_stack_1.FilterStackFactory(callConfig.dynamicFilterFactories);\n          const dynamicFilterStack = dynamicFilterStackFactory.createFilter(stream);\n          dynamicFilterStack.sendMetadata(Promise.resolve(metadata)).then(filteredMetadata => {\n            this.tryPick(stream, filteredMetadata, callConfig, dynamicFilterStack.getFilters());\n          });\n        } else {\n          this.tryPick(stream, metadata, callConfig, []);\n        }\n      } else {\n        stream.cancelWithStatus(callConfig.status, 'Failed to route call to method ' + stream.getMethod());\n      }\n    }\n  }\n\n  _startCallStream(stream, metadata) {\n    this.tryGetConfig(stream, metadata.clone());\n  }\n\n  close() {\n    this.resolvingLoadBalancer.destroy();\n    this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN);\n    clearInterval(this.callRefTimer);\n\n    if (this.channelzEnabled) {\n      channelz_1.unregisterChannelzRef(this.channelzRef);\n    }\n\n    this.subchannelPool.unrefUnusedSubchannels();\n  }\n\n  getTarget() {\n    return uri_parser_1.uriToString(this.target);\n  }\n\n  getConnectivityState(tryToConnect) {\n    const connectivityState = this.connectivityState;\n\n    if (tryToConnect) {\n      this.resolvingLoadBalancer.exitIdle();\n    }\n\n    return connectivityState;\n  }\n\n  watchConnectivityState(currentState, deadline, callback) {\n    if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n\n    let timer = null;\n\n    if (deadline !== Infinity) {\n      const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);\n      const now = new Date();\n\n      if (deadline === -Infinity || deadlineDate <= now) {\n        process.nextTick(callback, new Error('Deadline passed without connectivity state change'));\n        return;\n      }\n\n      timer = setTimeout(() => {\n        this.removeConnectivityStateWatcher(watcherObject);\n        callback(new Error('Deadline passed without connectivity state change'));\n      }, deadlineDate.getTime() - now.getTime());\n    }\n\n    const watcherObject = {\n      currentState,\n      callback,\n      timer\n    };\n    this.connectivityStateWatchers.push(watcherObject);\n  }\n  /**\n   * Get the channelz reference object for this channel. The returned value is\n   * garbage if channelz is disabled for this channel.\n   * @returns\n   */\n\n\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n\n  createCall(method, deadline, host, parentCall, propagateFlags) {\n    if (typeof method !== 'string') {\n      throw new TypeError('Channel#createCall: method must be a string');\n    }\n\n    if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n      throw new TypeError('Channel#createCall: deadline must be a number or Date');\n    }\n\n    if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n\n    const callNumber = getNewCallNumber();\n    this.trace('createCall [' + callNumber + '] method=\"' + method + '\", deadline=' + deadline);\n    const finalOptions = {\n      deadline: deadline,\n      flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,\n      host: host !== null && host !== void 0 ? host : this.defaultAuthority,\n      parentCall: parentCall\n    };\n    const stream = new call_stream_1.Http2CallStream(method, this, finalOptions, this.filterStackFactory, this.credentials._getCallCredentials(), callNumber);\n\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      stream.addStatusWatcher(status => {\n        if (status.code === constants_1.Status.OK) {\n          this.callTracker.addCallSucceeded();\n        } else {\n          this.callTracker.addCallFailed();\n        }\n      });\n    }\n\n    return stream;\n  }\n\n}\n\nexports.ChannelImplementation = ChannelImplementation;","map":{"version":3,"mappings":"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","names":["MAX_TIMEOUT_TIME","nextCallNumber","getNewCallNumber","callNumber","Number","MAX_SAFE_INTEGER","ChannelImplementation","constructor","target","credentials","options","connectivity_state_1","IDLE","picker_1","channelz_1","TypeError","channel_credentials_1","originalTarget","originalTargetUri","uri_parser_1","Error","defaultSchemeMapResult","resolver_1","callRefTimer","setInterval","unref","_b","channelzEnabled","channelzTrace","channelzRef","getChannelzInfo","addTrace","defaultAuthority","proxyMapResult","http_proxy_1","Object","assign","extraOptions","subchannelPool","subchannel_pool_1","_c","channelControlHelper","createSubchannel","subchannelAddress","subchannelArgs","subchannel","getOrCreateSubchannel","getChannelzRef","updateState","connectivityState","picker","currentPicker","queueCopy","pickQueue","slice","callRefTimerUnref","callStream","callMetadata","callConfig","dynamicFilters","tryPick","requestReresolution","addChannelzChild","child","childrenTracker","refChild","removeChannelzChild","unrefChild","resolvingLoadBalancer","resolving_load_balancer_1","configSelector","currentResolutionError","process","nextTick","localQueue","configSelectionQueue","tryGetConfig","status","code","details","length","trace","getOptions","waitForReady","callRefTimerRef","push","cancelWithStatus","filterStackFactory","filter_stack_1","call_credentials_filter_1","deadline_filter_1","max_message_size_filter_1","compression_filter_1","JSON","stringify","undefined","error","logging_1","constants_1","DEBUG","id","stack","_d","substring","indexOf","state","callTracker","children","getChildLists","text","verbosityOverride","hasRef","ref","pushPick","pickResult","pick","metadata","extraPickInfo","pickInformation","subchannelString","getAddress","getCallNumber","pickResultType","_a","COMPLETE","UNAVAILABLE","getConnectivityState","READY","ERROR","filterStack","sendMetadata","Promise","resolve","clone","then","finalMetadata","subchannelState","pickExtraFilters","extraFilterFactories","map","factory","createFilter","getRealSubchannel","startCallStream","onCommitted","onCallStarted","errorCode","message","INFO","INTERNAL","UNKNOWN","QUEUE","TRANSIENT_FAILURE","DROP","removeConnectivityStateWatcher","watcherObject","watcherIndex","connectivityStateWatchers","findIndex","value","splice","newState","watchersCopy","currentState","timer","clearTimeout","callback","stream","getStatus","exitIdle","getMethod","OK","methodConfig","timeout","deadline","Date","setSeconds","getSeconds","seconds","setMilliseconds","getMilliseconds","nanos","setConfigDeadline","refresh","dynamicFilterFactories","dynamicFilterStackFactory","dynamicFilterStack","filteredMetadata","getFilters","_startCallStream","close","destroy","SHUTDOWN","clearInterval","unrefUnusedSubchannels","getTarget","tryToConnect","watchConnectivityState","Infinity","deadlineDate","now","setTimeout","getTime","createCall","method","host","parentCall","propagateFlags","finalOptions","flags","DEFAULTS","call_stream_1","_getCallCredentials","addCallStarted","addStatusWatcher","addCallSucceeded","addCallFailed","exports"],"sources":["C:\\Users\\binel\\OneDrive\\Desktop\\Today\\Udemy\\iProfiler\\iProfiler\\iprofiler\\node_modules\\@grpc\\grpc-js\\src\\channel.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  Deadline,\n  Call,\n  Http2CallStream,\n  CallStreamOptions,\n  StatusObject,\n} from './call-stream';\nimport { ChannelCredentials } from './channel-credentials';\nimport { ChannelOptions } from './channel-options';\nimport { ResolvingLoadBalancer } from './resolving-load-balancer';\nimport { SubchannelPool, getSubchannelPool } from './subchannel-pool';\nimport { ChannelControlHelper } from './load-balancer';\nimport { UnavailablePicker, Picker, PickResultType } from './picker';\nimport { Metadata } from './metadata';\nimport { Status, LogVerbosity, Propagate } from './constants';\nimport { FilterStackFactory } from './filter-stack';\nimport { CallCredentialsFilterFactory } from './call-credentials-filter';\nimport { DeadlineFilterFactory } from './deadline-filter';\nimport { CompressionFilterFactory } from './compression-filter';\nimport {\n  CallConfig,\n  ConfigSelector,\n  getDefaultAuthority,\n  mapUriDefaultScheme,\n} from './resolver';\nimport { trace, log } from './logging';\nimport { SubchannelAddress } from './subchannel-address';\nimport { MaxMessageSizeFilterFactory } from './max-message-size-filter';\nimport { mapProxyName } from './http_proxy';\nimport { GrpcUri, parseUri, uriToString } from './uri-parser';\nimport { ServerSurfaceCall } from './server-call';\nimport { Filter } from './filter';\n\nimport { ConnectivityState } from './connectivity-state';\nimport { ChannelInfo, ChannelRef, ChannelzCallTracker, ChannelzChildrenTracker, ChannelzTrace, registerChannelzChannel, SubchannelRef, unregisterChannelzRef } from './channelz';\nimport { Subchannel } from './subchannel';\n\n/**\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\n */\nconst MAX_TIMEOUT_TIME = 2147483647;\n\nlet nextCallNumber = 0;\n\nfunction getNewCallNumber(): number {\n  const callNumber = nextCallNumber;\n  nextCallNumber += 1;\n  if (nextCallNumber >= Number.MAX_SAFE_INTEGER) {\n    nextCallNumber = 0;\n  }\n  return callNumber;\n}\n\n/**\n * An interface that represents a communication channel to a server specified\n * by a given address.\n */\nexport interface Channel {\n  /**\n   * Close the channel. This has the same functionality as the existing\n   * grpc.Client.prototype.close\n   */\n  close(): void;\n  /**\n   * Return the target that this channel connects to\n   */\n  getTarget(): string;\n  /**\n   * Get the channel's current connectivity state. This method is here mainly\n   * because it is in the existing internal Channel class, and there isn't\n   * another good place to put it.\n   * @param tryToConnect If true, the channel will start connecting if it is\n   *     idle. Otherwise, idle channels will only start connecting when a\n   *     call starts.\n   */\n  getConnectivityState(tryToConnect: boolean): ConnectivityState;\n  /**\n   * Watch for connectivity state changes. This is also here mainly because\n   * it is in the existing external Channel class.\n   * @param currentState The state to watch for transitions from. This should\n   *     always be populated by calling getConnectivityState immediately\n   *     before.\n   * @param deadline A deadline for waiting for a state change\n   * @param callback Called with no error when a state change, or with an\n   *     error if the deadline passes without a state change.\n   */\n  watchConnectivityState(\n    currentState: ConnectivityState,\n    deadline: Date | number,\n    callback: (error?: Error) => void\n  ): void;\n  /**\n   * Get the channelz reference object for this channel. A request to the\n   * channelz service for the id in this object will provide information\n   * about this channel.\n   */\n  getChannelzRef(): ChannelRef;\n  /**\n   * Create a call object. Call is an opaque type that is used by the Client\n   * class. This function is called by the gRPC library when starting a\n   * request. Implementers should return an instance of Call that is returned\n   * from calling createCall on an instance of the provided Channel class.\n   * @param method The full method string to request.\n   * @param deadline The call deadline\n   * @param host A host string override for making the request\n   * @param parentCall A server call to propagate some information from\n   * @param propagateFlags A bitwise combination of elements of grpc.propagate\n   *     that indicates what information to propagate from parentCall.\n   */\n  createCall(\n    method: string,\n    deadline: Deadline,\n    host: string | null | undefined,\n    parentCall: ServerSurfaceCall | null,\n    propagateFlags: number | null | undefined\n  ): Call;\n}\n\ninterface ConnectivityStateWatcher {\n  currentState: ConnectivityState;\n  timer: NodeJS.Timeout | null;\n  callback: (error?: Error) => void;\n}\n\nexport class ChannelImplementation implements Channel {\n  private resolvingLoadBalancer: ResolvingLoadBalancer;\n  private subchannelPool: SubchannelPool;\n  private connectivityState: ConnectivityState = ConnectivityState.IDLE;\n  private currentPicker: Picker = new UnavailablePicker();\n  /**\n   * Calls queued up to get a call config. Should only be populated before the\n   * first time the resolver returns a result, which includes the ConfigSelector.\n   */\n  private configSelectionQueue: Array<{\n    callStream: Http2CallStream;\n    callMetadata: Metadata;\n  }> = [];\n  private pickQueue: Array<{\n    callStream: Http2CallStream;\n    callMetadata: Metadata;\n    callConfig: CallConfig;\n    dynamicFilters: Filter[];\n  }> = [];\n  private connectivityStateWatchers: ConnectivityStateWatcher[] = [];\n  private defaultAuthority: string;\n  private filterStackFactory: FilterStackFactory;\n  private target: GrpcUri;\n  /**\n   * This timer does not do anything on its own. Its purpose is to hold the\n   * event loop open while there are any pending calls for the channel that\n   * have not yet been assigned to specific subchannels. In other words,\n   * the invariant is that callRefTimer is reffed if and only if pickQueue\n   * is non-empty.\n   */\n  private callRefTimer: NodeJS.Timer;\n  private configSelector: ConfigSelector | null = null;\n  /**\n   * This is the error from the name resolver if it failed most recently. It\n   * is only used to end calls that start while there is no config selector\n   * and the name resolver is in backoff, so it should be nulled if\n   * configSelector becomes set or the channel state becomes anything other\n   * than TRANSIENT_FAILURE.\n   */\n  private currentResolutionError: StatusObject | null = null;\n\n  // Channelz info\n  private readonly channelzEnabled: boolean = true;\n  private originalTarget: string;\n  private channelzRef: ChannelRef;\n  private channelzTrace: ChannelzTrace;\n  private callTracker = new ChannelzCallTracker();\n  private childrenTracker = new ChannelzChildrenTracker();\n\n  constructor(\n    target: string,\n    private readonly credentials: ChannelCredentials,\n    private readonly options: ChannelOptions\n  ) {\n    if (typeof target !== 'string') {\n      throw new TypeError('Channel target must be a string');\n    }\n    if (!(credentials instanceof ChannelCredentials)) {\n      throw new TypeError(\n        'Channel credentials must be a ChannelCredentials object'\n      );\n    }\n    if (options) {\n      if (typeof options !== 'object') {\n        throw new TypeError('Channel options must be an object');\n      }\n    }\n    this.originalTarget = target;\n    const originalTargetUri = parseUri(target);\n    if (originalTargetUri === null) {\n      throw new Error(`Could not parse target name \"${target}\"`);\n    }\n    /* This ensures that the target has a scheme that is registered with the\n     * resolver */\n    const defaultSchemeMapResult = mapUriDefaultScheme(originalTargetUri);\n    if (defaultSchemeMapResult === null) {\n      throw new Error(\n        `Could not find a default scheme for target name \"${target}\"`\n      );\n    }\n\n    this.callRefTimer = setInterval(() => {}, MAX_TIMEOUT_TIME);\n    this.callRefTimer.unref?.();\n\n    if (this.options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n\n    this.channelzTrace = new ChannelzTrace();\n    this.channelzRef = registerChannelzChannel(target, () => this.getChannelzInfo(), this.channelzEnabled);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Channel created');\n    }\n\n    if (this.options['grpc.default_authority']) {\n      this.defaultAuthority = this.options['grpc.default_authority'] as string;\n    } else {\n      this.defaultAuthority = getDefaultAuthority(defaultSchemeMapResult);\n    }\n    const proxyMapResult = mapProxyName(defaultSchemeMapResult, options);\n    this.target = proxyMapResult.target;\n    this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\n\n    /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n     * the grpc.use_local_subchannel_pool channel option means. */\n    this.subchannelPool = getSubchannelPool(\n      (options['grpc.use_local_subchannel_pool'] ?? 0) === 0\n    );\n    const channelControlHelper: ChannelControlHelper = {\n      createSubchannel: (\n        subchannelAddress: SubchannelAddress,\n        subchannelArgs: ChannelOptions\n      ) => {\n        const subchannel = this.subchannelPool.getOrCreateSubchannel(\n          this.target,\n          subchannelAddress,\n          Object.assign({}, this.options, subchannelArgs),\n          this.credentials\n        );\n        if (this.channelzEnabled) {\n          this.channelzTrace.addTrace('CT_INFO', 'Created subchannel or used existing subchannel', subchannel.getChannelzRef());\n        }\n        return subchannel;\n      },\n      updateState: (connectivityState: ConnectivityState, picker: Picker) => {\n        this.currentPicker = picker;\n        const queueCopy = this.pickQueue.slice();\n        this.pickQueue = [];\n        this.callRefTimerUnref();\n        for (const { callStream, callMetadata, callConfig, dynamicFilters } of queueCopy) {\n          this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n        }\n        this.updateState(connectivityState);\n      },\n      requestReresolution: () => {\n        // This should never be called.\n        throw new Error(\n          'Resolving load balancer should never call requestReresolution'\n        );\n      },\n      addChannelzChild: (child: ChannelRef | SubchannelRef) => {\n        if (this.channelzEnabled) {\n          this.childrenTracker.refChild(child);\n        }\n      },\n      removeChannelzChild: (child: ChannelRef | SubchannelRef) => {\n        if (this.channelzEnabled) {\n          this.childrenTracker.unrefChild(child);\n        }\n      }\n    };\n    this.resolvingLoadBalancer = new ResolvingLoadBalancer(\n      this.target,\n      channelControlHelper,\n      options,\n      (configSelector) => {\n        if (this.channelzEnabled) {\n          this.channelzTrace.addTrace('CT_INFO', 'Address resolution succeeded');\n        }\n        this.configSelector = configSelector;\n        this.currentResolutionError = null;\n        /* We process the queue asynchronously to ensure that the corresponding\n         * load balancer update has completed. */\n        process.nextTick(() => {\n          const localQueue = this.configSelectionQueue;\n          this.configSelectionQueue = [];\n          this.callRefTimerUnref();\n          for (const { callStream, callMetadata } of localQueue) {\n            this.tryGetConfig(callStream, callMetadata);\n          }\n          this.configSelectionQueue = [];\n        });\n      },\n      (status) => {\n        if (this.channelzEnabled) {\n          this.channelzTrace.addTrace('CT_WARNING', 'Address resolution failed with code ' + status.code + ' and details \"' + status.details + '\"');\n        }\n        if (this.configSelectionQueue.length > 0) {\n          this.trace('Name resolution failed with calls queued for config selection');\n        }\n        if (this.configSelector === null) {\n          this.currentResolutionError = status;\n        }\n        const localQueue = this.configSelectionQueue;\n        this.configSelectionQueue = [];\n        this.callRefTimerUnref();\n        for (const { callStream, callMetadata } of localQueue) {\n          if (callMetadata.getOptions().waitForReady) {\n            this.callRefTimerRef();\n            this.configSelectionQueue.push({ callStream, callMetadata });\n          } else {\n            callStream.cancelWithStatus(status.code, status.details);\n          }\n        }\n      }\n    );\n    this.filterStackFactory = new FilterStackFactory([\n      new CallCredentialsFilterFactory(this),\n      new DeadlineFilterFactory(this),\n      new MaxMessageSizeFilterFactory(this.options),\n      new CompressionFilterFactory(this, this.options),\n    ]);\n    this.trace('Channel constructed with options ' + JSON.stringify(options, undefined, 2));\n    const error = new Error();\n    trace(LogVerbosity.DEBUG, 'channel_stacktrace', '(' + this.channelzRef.id + ') ' + 'Channel constructed \\n' + error.stack?.substring(error.stack.indexOf('\\n')+1));\n  }\n\n  private getChannelzInfo(): ChannelInfo {\n    return {\n      target: this.originalTarget,\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists()\n    };\n  }\n\n  private trace(text: string, verbosityOverride?: LogVerbosity) {\n    trace(verbosityOverride ?? LogVerbosity.DEBUG, 'channel', '(' + this.channelzRef.id + ') ' + uriToString(this.target) + ' ' + text);\n  }\n\n  private callRefTimerRef() {\n    // If the hasRef function does not exist, always run the code\n    if (!this.callRefTimer.hasRef?.()) {\n      this.trace(\n        'callRefTimer.ref | configSelectionQueue.length=' +\n          this.configSelectionQueue.length +\n          ' pickQueue.length=' +\n          this.pickQueue.length\n      );\n      this.callRefTimer.ref?.();\n    }\n  }\n\n  private callRefTimerUnref() {\n    // If the hasRef function does not exist, always run the code\n    if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {\n      this.trace(\n        'callRefTimer.unref | configSelectionQueue.length=' +\n          this.configSelectionQueue.length +\n          ' pickQueue.length=' +\n          this.pickQueue.length\n      );\n      this.callRefTimer.unref?.();\n    }\n  }\n\n  private pushPick(\n    callStream: Http2CallStream,\n    callMetadata: Metadata,\n    callConfig: CallConfig,\n    dynamicFilters: Filter[]\n  ) {\n    this.pickQueue.push({ callStream, callMetadata, callConfig, dynamicFilters });\n    this.callRefTimerRef();\n  }\n\n  /**\n   * Check the picker output for the given call and corresponding metadata,\n   * and take any relevant actions. Should not be called while iterating\n   * over pickQueue.\n   * @param callStream\n   * @param callMetadata\n   */\n  private tryPick(\n    callStream: Http2CallStream,\n    callMetadata: Metadata,\n    callConfig: CallConfig,\n    dynamicFilters: Filter[]\n  ) {\n    const pickResult = this.currentPicker.pick({\n      metadata: callMetadata,\n      extraPickInfo: callConfig.pickInformation,\n    });\n    const subchannelString = pickResult.subchannel ? \n      '(' + pickResult.subchannel.getChannelzRef().id + ') ' + pickResult.subchannel.getAddress() : \n      '' + pickResult.subchannel; \n    this.trace(\n      'Pick result for call [' + \n        callStream.getCallNumber() + \n        ']: ' +\n        PickResultType[pickResult.pickResultType] +\n        ' subchannel: ' +\n        subchannelString +\n        ' status: ' +\n        pickResult.status?.code +\n        ' ' +\n        pickResult.status?.details\n    );\n    switch (pickResult.pickResultType) {\n      case PickResultType.COMPLETE:\n        if (pickResult.subchannel === null) {\n          callStream.cancelWithStatus(\n            Status.UNAVAILABLE,\n            'Request dropped by load balancing policy'\n          );\n          // End the call with an error\n        } else {\n          /* If the subchannel is not in the READY state, that indicates a bug\n           * somewhere in the load balancer or picker. So, we log an error and\n           * queue the pick to be tried again later. */\n          if (\n            pickResult.subchannel!.getConnectivityState() !==\n            ConnectivityState.READY\n          ) {\n            log(\n              LogVerbosity.ERROR,\n              'Error: COMPLETE pick result subchannel ' +\n                subchannelString +\n                ' has state ' +\n                ConnectivityState[pickResult.subchannel!.getConnectivityState()]\n            );\n            this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n            break;\n          }\n          /* We need to clone the callMetadata here because the transparent\n           * retry code in the promise resolution handler use the same\n           * callMetadata object, so it needs to stay unmodified */\n          callStream.filterStack\n            .sendMetadata(Promise.resolve(callMetadata.clone()))\n            .then(\n              (finalMetadata) => {\n                const subchannelState: ConnectivityState = pickResult.subchannel!.getConnectivityState();\n                if (subchannelState === ConnectivityState.READY) {\n                  try {\n                    const pickExtraFilters = pickResult.extraFilterFactories.map(factory => factory.createFilter(callStream));\n                    pickResult.subchannel?.getRealSubchannel().startCallStream(\n                      finalMetadata,\n                      callStream,\n                      [...dynamicFilters, ...pickExtraFilters]\n                    );\n                    /* If we reach this point, the call stream has started\n                     * successfully */\n                    callConfig.onCommitted?.();\n                    pickResult.onCallStarted?.();\n                  } catch (error) {\n                    const errorCode = (error as NodeJS.ErrnoException).code;\n                    if (errorCode === 'ERR_HTTP2_GOAWAY_SESSION' ||\n                        errorCode === 'ERR_HTTP2_INVALID_SESSION'\n                    ) {\n                      /* An error here indicates that something went wrong with\n                       * the picked subchannel's http2 stream right before we\n                       * tried to start the stream. We are handling a promise\n                       * result here, so this is asynchronous with respect to the\n                       * original tryPick call, so calling it again is not\n                       * recursive. We call tryPick immediately instead of\n                       * queueing this pick again because handling the queue is\n                       * triggered by state changes, and we want to immediately\n                       * check if the state has already changed since the\n                       * previous tryPick call. We do this instead of cancelling\n                       * the stream because the correct behavior may be\n                       * re-queueing instead, based on the logic in the rest of\n                       * tryPick */\n                      this.trace(\n                        'Failed to start call on picked subchannel ' +\n                          subchannelString +\n                          ' with error ' +\n                          (error as Error).message +\n                          '. Retrying pick',\n                          LogVerbosity.INFO\n                      );\n                      this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n                    } else {\n                      this.trace(\n                        'Failed to start call on picked subchanel ' +\n                          subchannelString +\n                          ' with error ' +\n                          (error as Error).message +\n                          '. Ending call',\n                          LogVerbosity.INFO\n                      );\n                      callStream.cancelWithStatus(\n                        Status.INTERNAL,\n                        `Failed to start HTTP/2 stream with error: ${\n                          (error as Error).message\n                        }`\n                      );\n                    }\n                  }\n                } else {\n                  /* The logic for doing this here is the same as in the catch\n                   * block above */\n                  this.trace(\n                    'Picked subchannel ' +\n                      subchannelString +\n                      ' has state ' +\n                      ConnectivityState[subchannelState] +\n                      ' after metadata filters. Retrying pick',\n                      LogVerbosity.INFO\n                  );\n                  this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n                }\n              },\n              (error: Error & { code: number }) => {\n                // We assume the error code isn't 0 (Status.OK)\n                callStream.cancelWithStatus(\n                  typeof error.code === 'number' ? error.code : Status.UNKNOWN,\n                  `Getting metadata from plugin failed with error: ${error.message}`\n                );\n              }\n            );\n        }\n        break;\n      case PickResultType.QUEUE:\n        this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n        break;\n      case PickResultType.TRANSIENT_FAILURE:\n        if (callMetadata.getOptions().waitForReady) {\n          this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n        } else {\n          callStream.cancelWithStatus(\n            pickResult.status!.code,\n            pickResult.status!.details\n          );\n        }\n        break;\n      case PickResultType.DROP:\n        callStream.cancelWithStatus(\n          pickResult.status!.code,\n          pickResult.status!.details\n        );\n        break;\n      default:\n        throw new Error(\n          `Invalid state: unknown pickResultType ${pickResult.pickResultType}`\n        );\n    }\n  }\n\n  private removeConnectivityStateWatcher(\n    watcherObject: ConnectivityStateWatcher\n  ) {\n    const watcherIndex = this.connectivityStateWatchers.findIndex(\n      (value) => value === watcherObject\n    );\n    if (watcherIndex >= 0) {\n      this.connectivityStateWatchers.splice(watcherIndex, 1);\n    }\n  }\n\n  private updateState(newState: ConnectivityState): void {\n    trace(\n      LogVerbosity.DEBUG,\n      'connectivity_state',\n      '(' + this.channelzRef.id + ') ' + \n        uriToString(this.target) +\n        ' ' +\n        ConnectivityState[this.connectivityState] +\n        ' -> ' +\n        ConnectivityState[newState]\n    );\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', ConnectivityState[this.connectivityState] + ' -> ' + ConnectivityState[newState]);\n    }\n    this.connectivityState = newState;\n    const watchersCopy = this.connectivityStateWatchers.slice();\n    for (const watcherObject of watchersCopy) {\n      if (newState !== watcherObject.currentState) {\n        if (watcherObject.timer) {\n          clearTimeout(watcherObject.timer);\n        }\n        this.removeConnectivityStateWatcher(watcherObject);\n        watcherObject.callback();\n      }\n    }\n    if (newState !== ConnectivityState.TRANSIENT_FAILURE) {\n      this.currentResolutionError = null;\n    }\n  }\n\n  private tryGetConfig(stream: Http2CallStream, metadata: Metadata) {\n    if (stream.getStatus() !== null) {\n      /* If the stream has a status, it has already finished and we don't need\n       * to take any more actions on it. */\n      return;\n    }\n    if (this.configSelector === null) {\n      /* This branch will only be taken at the beginning of the channel's life,\n       * before the resolver ever returns a result. So, the\n       * ResolvingLoadBalancer may be idle and if so it needs to be kicked\n       * because it now has a pending request. */\n      this.resolvingLoadBalancer.exitIdle();\n      if (this.currentResolutionError && !metadata.getOptions().waitForReady) {\n        stream.cancelWithStatus(this.currentResolutionError.code, this.currentResolutionError.details);\n      } else {\n        this.configSelectionQueue.push({\n          callStream: stream,\n          callMetadata: metadata,\n        });\n        this.callRefTimerRef();\n      }\n    } else {\n      const callConfig = this.configSelector(stream.getMethod(), metadata);\n      if (callConfig.status === Status.OK) {\n        if (callConfig.methodConfig.timeout) {\n          const deadline = new Date();\n          deadline.setSeconds(\n            deadline.getSeconds() + callConfig.methodConfig.timeout.seconds\n          );\n          deadline.setMilliseconds(\n            deadline.getMilliseconds() +\n              callConfig.methodConfig.timeout.nanos / 1_000_000\n          );\n          stream.setConfigDeadline(deadline);\n          // Refreshing the filters makes the deadline filter pick up the new deadline\n          stream.filterStack.refresh();\n        }\n        if (callConfig.dynamicFilterFactories.length > 0) {\n          /* These dynamicFilters are the mechanism for implementing gRFC A39:\n           * https://github.com/grpc/proposal/blob/master/A39-xds-http-filters.md\n           * We run them here instead of with the rest of the filters because\n           * that spec says \"the xDS HTTP filters will run in between name \n           * resolution and load balancing\".\n           * \n           * We use the filter stack here to simplify the multi-filter async\n           * waterfall logic, but we pass along the underlying list of filters\n           * to avoid having nested filter stacks when combining it with the\n           * original filter stack. We do not pass along the original filter\n           * factory list because these filters may need to persist data\n           * between sending headers and other operations. */\n          const dynamicFilterStackFactory = new FilterStackFactory(callConfig.dynamicFilterFactories);\n          const dynamicFilterStack = dynamicFilterStackFactory.createFilter(stream);\n          dynamicFilterStack.sendMetadata(Promise.resolve(metadata)).then(filteredMetadata => {\n            this.tryPick(stream, filteredMetadata, callConfig, dynamicFilterStack.getFilters());\n          });\n        } else {\n          this.tryPick(stream, metadata, callConfig, []);\n        }\n      } else {\n        stream.cancelWithStatus(\n          callConfig.status,\n          'Failed to route call to method ' + stream.getMethod()\n        );\n      }\n    }\n  }\n\n  _startCallStream(stream: Http2CallStream, metadata: Metadata) {\n    this.tryGetConfig(stream, metadata.clone());\n  }\n\n  close() {\n    this.resolvingLoadBalancer.destroy();\n    this.updateState(ConnectivityState.SHUTDOWN);\n    clearInterval(this.callRefTimer);\n    if (this.channelzEnabled) {\n      unregisterChannelzRef(this.channelzRef);\n    }\n\n    this.subchannelPool.unrefUnusedSubchannels();\n  }\n\n  getTarget() {\n    return uriToString(this.target);\n  }\n\n  getConnectivityState(tryToConnect: boolean) {\n    const connectivityState = this.connectivityState;\n    if (tryToConnect) {\n      this.resolvingLoadBalancer.exitIdle();\n    }\n    return connectivityState;\n  }\n\n  watchConnectivityState(\n    currentState: ConnectivityState,\n    deadline: Date | number,\n    callback: (error?: Error) => void\n  ): void {\n    if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n    let timer = null;\n    if (deadline !== Infinity) {\n      const deadlineDate: Date =\n        deadline instanceof Date ? deadline : new Date(deadline);\n      const now = new Date();\n      if (deadline === -Infinity || deadlineDate <= now) {\n        process.nextTick(\n          callback,\n          new Error('Deadline passed without connectivity state change')\n        );\n        return;\n      }\n      timer = setTimeout(() => {\n        this.removeConnectivityStateWatcher(watcherObject);\n        callback(\n          new Error('Deadline passed without connectivity state change')\n        );\n      }, deadlineDate.getTime() - now.getTime());\n    }\n    const watcherObject = {\n      currentState,\n      callback,\n      timer,\n    };\n    this.connectivityStateWatchers.push(watcherObject);\n  }\n\n  /**\n   * Get the channelz reference object for this channel. The returned value is\n   * garbage if channelz is disabled for this channel.\n   * @returns \n   */\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n\n  createCall(\n    method: string,\n    deadline: Deadline,\n    host: string | null | undefined,\n    parentCall: ServerSurfaceCall | null,\n    propagateFlags: number | null | undefined\n  ): Call {\n    if (typeof method !== 'string') {\n      throw new TypeError('Channel#createCall: method must be a string');\n    }\n    if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n      throw new TypeError(\n        'Channel#createCall: deadline must be a number or Date'\n      );\n    }\n    if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n    const callNumber = getNewCallNumber();\n    this.trace(\n      'createCall [' +\n        callNumber +\n        '] method=\"' +\n        method +\n        '\", deadline=' +\n        deadline\n    );\n    const finalOptions: CallStreamOptions = {\n      deadline: deadline,\n      flags: propagateFlags ?? Propagate.DEFAULTS,\n      host: host ?? this.defaultAuthority,\n      parentCall: parentCall,\n    };\n    const stream: Http2CallStream = new Http2CallStream(\n      method,\n      this,\n      finalOptions,\n      this.filterStackFactory,\n      this.credentials._getCallCredentials(),\n      callNumber\n    );\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      stream.addStatusWatcher(status => {\n        if (status.code === Status.OK) {\n          this.callTracker.addCallSucceeded();\n        } else {\n          this.callTracker.addCallFailed();\n        }\n      });\n    }\n    return stream;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}