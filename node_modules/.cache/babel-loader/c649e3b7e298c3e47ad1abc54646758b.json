{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setup = exports.OutlierDetectionLoadBalancer = exports.OutlierDetectionLoadBalancingConfig = void 0;\n\nconst connectivity_state_1 = require(\"./connectivity-state\");\n\nconst constants_1 = require(\"./constants\");\n\nconst duration_1 = require(\"./duration\");\n\nconst experimental_1 = require(\"./experimental\");\n\nconst filter_1 = require(\"./filter\");\n\nconst load_balancer_1 = require(\"./load-balancer\");\n\nconst load_balancer_child_handler_1 = require(\"./load-balancer-child-handler\");\n\nconst picker_1 = require(\"./picker\");\n\nconst subchannel_address_1 = require(\"./subchannel-address\");\n\nconst subchannel_interface_1 = require(\"./subchannel-interface\");\n\nconst TYPE_NAME = 'outlier_detection';\nconst OUTLIER_DETECTION_ENABLED = process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION === 'true';\nconst defaultSuccessRateEjectionConfig = {\n  stdev_factor: 1900,\n  enforcement_percentage: 100,\n  minimum_hosts: 5,\n  request_volume: 100\n};\nconst defaultFailurePercentageEjectionConfig = {\n  threshold: 85,\n  enforcement_percentage: 100,\n  minimum_hosts: 5,\n  request_volume: 50\n};\n\nfunction validateFieldType(obj, fieldName, expectedType, objectName) {\n  if (fieldName in obj && typeof obj[fieldName] !== expectedType) {\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n    throw new Error(`outlier detection config ${fullFieldName} parse error: expected ${expectedType}, got ${typeof obj[fieldName]}`);\n  }\n}\n\nfunction validatePositiveDuration(obj, fieldName, objectName) {\n  const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n\n  if (fieldName in obj) {\n    if (!duration_1.isDuration(obj[fieldName])) {\n      throw new Error(`outlier detection config ${fullFieldName} parse error: expected Duration, got ${typeof obj[fieldName]}`);\n    }\n\n    if (!(obj[fieldName].seconds >= 0 && obj[fieldName].seconds <= 315576000000 && obj[fieldName].nanos >= 0 && obj[fieldName].nanos <= 999999999)) {\n      throw new Error(`outlier detection config ${fullFieldName} parse error: values out of range for non-negative Duaration`);\n    }\n  }\n}\n\nfunction validatePercentage(obj, fieldName, objectName) {\n  const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n  validateFieldType(obj, fieldName, 'number', objectName);\n\n  if (fieldName in obj && !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) {\n    throw new Error(`outlier detection config ${fullFieldName} parse error: value out of range for percentage (0-100)`);\n  }\n}\n\nclass OutlierDetectionLoadBalancingConfig {\n  constructor(intervalMs, baseEjectionTimeMs, maxEjectionTimeMs, maxEjectionPercent, successRateEjection, failurePercentageEjection, childPolicy) {\n    this.childPolicy = childPolicy;\n    this.intervalMs = intervalMs !== null && intervalMs !== void 0 ? intervalMs : 10000;\n    this.baseEjectionTimeMs = baseEjectionTimeMs !== null && baseEjectionTimeMs !== void 0 ? baseEjectionTimeMs : 30000;\n    this.maxEjectionTimeMs = maxEjectionTimeMs !== null && maxEjectionTimeMs !== void 0 ? maxEjectionTimeMs : 300000;\n    this.maxEjectionPercent = maxEjectionPercent !== null && maxEjectionPercent !== void 0 ? maxEjectionPercent : 10;\n    this.successRateEjection = successRateEjection ? Object.assign(Object.assign({}, defaultSuccessRateEjectionConfig), successRateEjection) : null;\n    this.failurePercentageEjection = failurePercentageEjection ? Object.assign(Object.assign({}, defaultFailurePercentageEjectionConfig), failurePercentageEjection) : null;\n  }\n\n  getLoadBalancerName() {\n    return TYPE_NAME;\n  }\n\n  toJsonObject() {\n    return {\n      interval: duration_1.msToDuration(this.intervalMs),\n      base_ejection_time: duration_1.msToDuration(this.baseEjectionTimeMs),\n      max_ejection_time: duration_1.msToDuration(this.maxEjectionTimeMs),\n      max_ejection_percent: this.maxEjectionPercent,\n      success_rate_ejection: this.successRateEjection,\n      failure_percentage_ejection: this.failurePercentageEjection,\n      child_policy: this.childPolicy.map(policy => policy.toJsonObject())\n    };\n  }\n\n  getIntervalMs() {\n    return this.intervalMs;\n  }\n\n  getBaseEjectionTimeMs() {\n    return this.baseEjectionTimeMs;\n  }\n\n  getMaxEjectionTimeMs() {\n    return this.maxEjectionTimeMs;\n  }\n\n  getMaxEjectionPercent() {\n    return this.maxEjectionPercent;\n  }\n\n  getSuccessRateEjectionConfig() {\n    return this.successRateEjection;\n  }\n\n  getFailurePercentageEjectionConfig() {\n    return this.failurePercentageEjection;\n  }\n\n  getChildPolicy() {\n    return this.childPolicy;\n  }\n\n  copyWithChildPolicy(childPolicy) {\n    return new OutlierDetectionLoadBalancingConfig(this.intervalMs, this.baseEjectionTimeMs, this.maxEjectionTimeMs, this.maxEjectionPercent, this.successRateEjection, this.failurePercentageEjection, childPolicy);\n  }\n\n  static createFromJson(obj) {\n    var _a;\n\n    validatePositiveDuration(obj, 'interval');\n    validatePositiveDuration(obj, 'base_ejection_time');\n    validatePositiveDuration(obj, 'max_ejection_time');\n    validatePercentage(obj, 'max_ejection_percent');\n\n    if ('success_rate_ejection' in obj) {\n      if (typeof obj.success_rate_ejection !== 'object') {\n        throw new Error('outlier detection config success_rate_ejection must be an object');\n      }\n\n      validateFieldType(obj.success_rate_ejection, 'stdev_factor', 'number', 'success_rate_ejection');\n      validatePercentage(obj.success_rate_ejection, 'enforcement_percentage', 'success_rate_ejection');\n      validateFieldType(obj.success_rate_ejection, 'minimum_hosts', 'number', 'success_rate_ejection');\n      validateFieldType(obj.success_rate_ejection, 'request_volume', 'number', 'success_rate_ejection');\n    }\n\n    if ('failure_percentage_ejection' in obj) {\n      if (typeof obj.failure_percentage_ejection !== 'object') {\n        throw new Error('outlier detection config failure_percentage_ejection must be an object');\n      }\n\n      validatePercentage(obj.failure_percentage_ejection, 'threshold', 'failure_percentage_ejection');\n      validatePercentage(obj.failure_percentage_ejection, 'enforcement_percentage', 'failure_percentage_ejection');\n      validateFieldType(obj.failure_percentage_ejection, 'minimum_hosts', 'number', 'failure_percentage_ejection');\n      validateFieldType(obj.failure_percentage_ejection, 'request_volume', 'number', 'failure_percentage_ejection');\n    }\n\n    return new OutlierDetectionLoadBalancingConfig(obj.interval ? duration_1.durationToMs(obj.interval) : null, obj.base_ejection_time ? duration_1.durationToMs(obj.base_ejection_time) : null, obj.max_ejection_time ? duration_1.durationToMs(obj.max_ejection_time) : null, (_a = obj.max_ejection_percent) !== null && _a !== void 0 ? _a : null, obj.success_rate_ejection, obj.failure_percentage_ejection, obj.child_policy.map(load_balancer_1.validateLoadBalancingConfig));\n  }\n\n}\n\nexports.OutlierDetectionLoadBalancingConfig = OutlierDetectionLoadBalancingConfig;\n\nclass OutlierDetectionSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {\n  constructor(childSubchannel, mapEntry) {\n    super(childSubchannel);\n    this.mapEntry = mapEntry;\n    this.childSubchannelState = connectivity_state_1.ConnectivityState.IDLE;\n    this.stateListeners = [];\n    this.ejected = false;\n    this.refCount = 0;\n    childSubchannel.addConnectivityStateListener((subchannel, previousState, newState) => {\n      this.childSubchannelState = newState;\n\n      if (!this.ejected) {\n        for (const listener of this.stateListeners) {\n          listener(this, previousState, newState);\n        }\n      }\n    });\n  }\n  /**\n   * Add a listener function to be called whenever the wrapper's\n   * connectivity state changes.\n   * @param listener\n   */\n\n\n  addConnectivityStateListener(listener) {\n    this.stateListeners.push(listener);\n  }\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n\n\n  removeConnectivityStateListener(listener) {\n    const listenerIndex = this.stateListeners.indexOf(listener);\n\n    if (listenerIndex > -1) {\n      this.stateListeners.splice(listenerIndex, 1);\n    }\n  }\n\n  ref() {\n    this.child.ref();\n    this.refCount += 1;\n  }\n\n  unref() {\n    this.child.unref();\n    this.refCount -= 1;\n\n    if (this.refCount <= 0) {\n      if (this.mapEntry) {\n        const index = this.mapEntry.subchannelWrappers.indexOf(this);\n\n        if (index >= 0) {\n          this.mapEntry.subchannelWrappers.splice(index, 1);\n        }\n      }\n    }\n  }\n\n  eject() {\n    this.ejected = true;\n\n    for (const listener of this.stateListeners) {\n      listener(this, this.childSubchannelState, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n    }\n  }\n\n  uneject() {\n    this.ejected = false;\n\n    for (const listener of this.stateListeners) {\n      listener(this, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, this.childSubchannelState);\n    }\n  }\n\n  getMapEntry() {\n    return this.mapEntry;\n  }\n\n  getWrappedSubchannel() {\n    return this.child;\n  }\n\n}\n\nfunction createEmptyBucket() {\n  return {\n    success: 0,\n    failure: 0\n  };\n}\n\nclass CallCounter {\n  constructor() {\n    this.activeBucket = createEmptyBucket();\n    this.inactiveBucket = createEmptyBucket();\n  }\n\n  addSuccess() {\n    this.activeBucket.success += 1;\n  }\n\n  addFailure() {\n    this.activeBucket.failure += 1;\n  }\n\n  switchBuckets() {\n    this.inactiveBucket = this.activeBucket;\n    this.activeBucket = createEmptyBucket();\n  }\n\n  getLastSuccesses() {\n    return this.inactiveBucket.success;\n  }\n\n  getLastFailures() {\n    return this.inactiveBucket.failure;\n  }\n\n}\n\nclass OutlierDetectionCounterFilter extends filter_1.BaseFilter {\n  constructor(callCounter) {\n    super();\n    this.callCounter = callCounter;\n  }\n\n  receiveTrailers(status) {\n    if (status.code === constants_1.Status.OK) {\n      this.callCounter.addSuccess();\n    } else {\n      this.callCounter.addFailure();\n    }\n\n    return status;\n  }\n\n}\n\nclass OutlierDetectionCounterFilterFactory {\n  constructor(callCounter) {\n    this.callCounter = callCounter;\n  }\n\n  createFilter(callStream) {\n    return new OutlierDetectionCounterFilter(this.callCounter);\n  }\n\n}\n\nclass OutlierDetectionPicker {\n  constructor(wrappedPicker) {\n    this.wrappedPicker = wrappedPicker;\n  }\n\n  pick(pickArgs) {\n    const wrappedPick = this.wrappedPicker.pick(pickArgs);\n\n    if (wrappedPick.pickResultType === picker_1.PickResultType.COMPLETE) {\n      const subchannelWrapper = wrappedPick.subchannel;\n      const mapEntry = subchannelWrapper.getMapEntry();\n\n      if (mapEntry) {\n        return Object.assign(Object.assign({}, wrappedPick), {\n          subchannel: subchannelWrapper.getWrappedSubchannel(),\n          extraFilterFactories: [...wrappedPick.extraFilterFactories, new OutlierDetectionCounterFilterFactory(mapEntry.counter)]\n        });\n      } else {\n        return wrappedPick;\n      }\n    } else {\n      return wrappedPick;\n    }\n  }\n\n}\n\nclass OutlierDetectionLoadBalancer {\n  constructor(channelControlHelper) {\n    this.addressMap = new Map();\n    this.latestConfig = null;\n    this.childBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler(experimental_1.createChildChannelControlHelper(channelControlHelper, {\n      createSubchannel: (subchannelAddress, subchannelArgs) => {\n        const originalSubchannel = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n        const mapEntry = this.addressMap.get(subchannel_address_1.subchannelAddressToString(subchannelAddress));\n        const subchannelWrapper = new OutlierDetectionSubchannelWrapper(originalSubchannel, mapEntry);\n        mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.subchannelWrappers.push(subchannelWrapper);\n        return subchannelWrapper;\n      },\n      updateState: (connectivityState, picker) => {\n        if (connectivityState === connectivity_state_1.ConnectivityState.READY) {\n          channelControlHelper.updateState(connectivityState, new OutlierDetectionPicker(picker));\n        } else {\n          channelControlHelper.updateState(connectivityState, picker);\n        }\n      }\n    }));\n    this.ejectionTimer = setInterval(() => {}, 0);\n    clearInterval(this.ejectionTimer);\n  }\n\n  getCurrentEjectionPercent() {\n    let ejectionCount = 0;\n\n    for (const mapEntry of this.addressMap.values()) {\n      if (mapEntry.currentEjectionTimestamp !== null) {\n        ejectionCount += 1;\n      }\n    }\n\n    return ejectionCount * 100 / this.addressMap.size;\n  }\n\n  runSuccessRateCheck(ejectionTimestamp) {\n    if (!this.latestConfig) {\n      return;\n    }\n\n    const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();\n\n    if (!successRateConfig) {\n      return;\n    } // Step 1\n\n\n    const targetRequestVolume = successRateConfig.request_volume;\n    let addresesWithTargetVolume = 0;\n    const successRates = [];\n\n    for (const mapEntry of this.addressMap.values()) {\n      const successes = mapEntry.counter.getLastSuccesses();\n      const failures = mapEntry.counter.getLastFailures();\n\n      if (successes + failures >= targetRequestVolume) {\n        addresesWithTargetVolume += 1;\n        successRates.push(successes / (successes + failures));\n      }\n    }\n\n    if (addresesWithTargetVolume < successRateConfig.minimum_hosts) {\n      return;\n    } // Step 2\n\n\n    const successRateMean = successRates.reduce((a, b) => a + b);\n    let successRateVariance = 0;\n\n    for (const rate of successRates) {\n      const deviation = rate - successRateMean;\n      successRateVariance += deviation * deviation;\n    }\n\n    const successRateStdev = Math.sqrt(successRateVariance);\n    const ejectionThreshold = successRateMean - successRateStdev * (successRateConfig.stdev_factor / 1000); // Step 3\n\n    for (const mapEntry of this.addressMap.values()) {\n      // Step 3.i\n      if (this.getCurrentEjectionPercent() > this.latestConfig.getMaxEjectionPercent()) {\n        break;\n      } // Step 3.ii\n\n\n      const successes = mapEntry.counter.getLastSuccesses();\n      const failures = mapEntry.counter.getLastFailures();\n\n      if (successes + failures < targetRequestVolume) {\n        continue;\n      } // Step 3.iii\n\n\n      const successRate = successes / (successes + failures);\n\n      if (successRate < ejectionThreshold) {\n        const randomNumber = Math.random() * 100;\n\n        if (randomNumber < successRateConfig.enforcement_percentage) {\n          this.eject(mapEntry, ejectionTimestamp);\n        }\n      }\n    }\n  }\n\n  runFailurePercentageCheck(ejectionTimestamp) {\n    if (!this.latestConfig) {\n      return;\n    }\n\n    const failurePercentageConfig = this.latestConfig.getFailurePercentageEjectionConfig();\n\n    if (!failurePercentageConfig) {\n      return;\n    } // Step 1\n\n\n    if (this.addressMap.size < failurePercentageConfig.minimum_hosts) {\n      return;\n    } // Step 2\n\n\n    for (const mapEntry of this.addressMap.values()) {\n      // Step 2.i\n      if (this.getCurrentEjectionPercent() > this.latestConfig.getMaxEjectionPercent()) {\n        break;\n      } // Step 2.ii\n\n\n      const successes = mapEntry.counter.getLastSuccesses();\n      const failures = mapEntry.counter.getLastFailures();\n\n      if (successes + failures < failurePercentageConfig.request_volume) {\n        continue;\n      } // Step 2.iii\n\n\n      const failurePercentage = failures * 100 / (failures + successes);\n\n      if (failurePercentage > failurePercentageConfig.threshold) {\n        const randomNumber = Math.random() * 100;\n\n        if (randomNumber < failurePercentageConfig.enforcement_percentage) {\n          this.eject(mapEntry, ejectionTimestamp);\n        }\n      }\n    }\n  }\n\n  eject(mapEntry, ejectionTimestamp) {\n    mapEntry.currentEjectionTimestamp = new Date();\n    mapEntry.ejectionTimeMultiplier += 1;\n\n    for (const subchannelWrapper of mapEntry.subchannelWrappers) {\n      subchannelWrapper.eject();\n    }\n  }\n\n  uneject(mapEntry) {\n    mapEntry.currentEjectionTimestamp = null;\n\n    for (const subchannelWrapper of mapEntry.subchannelWrappers) {\n      subchannelWrapper.uneject();\n    }\n  }\n\n  runChecks() {\n    const ejectionTimestamp = new Date();\n\n    for (const mapEntry of this.addressMap.values()) {\n      mapEntry.counter.switchBuckets();\n    }\n\n    if (!this.latestConfig) {\n      return;\n    }\n\n    this.runSuccessRateCheck(ejectionTimestamp);\n    this.runFailurePercentageCheck(ejectionTimestamp);\n\n    for (const mapEntry of this.addressMap.values()) {\n      if (mapEntry.currentEjectionTimestamp === null) {\n        if (mapEntry.ejectionTimeMultiplier > 0) {\n          mapEntry.ejectionTimeMultiplier -= 1;\n        }\n      } else {\n        const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();\n        const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();\n        const returnTime = new Date(mapEntry.currentEjectionTimestamp.getTime());\n        returnTime.setMilliseconds(returnTime.getMilliseconds() + Math.min(baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier, Math.max(baseEjectionTimeMs, maxEjectionTimeMs)));\n\n        if (returnTime < new Date()) {\n          this.uneject(mapEntry);\n        }\n      }\n    }\n  }\n\n  updateAddressList(addressList, lbConfig, attributes) {\n    if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) {\n      return;\n    }\n\n    const subchannelAddresses = new Set();\n\n    for (const address of addressList) {\n      subchannelAddresses.add(subchannel_address_1.subchannelAddressToString(address));\n    }\n\n    for (const address of subchannelAddresses) {\n      if (!this.addressMap.has(address)) {\n        this.addressMap.set(address, {\n          counter: new CallCounter(),\n          currentEjectionTimestamp: null,\n          ejectionTimeMultiplier: 0,\n          subchannelWrappers: []\n        });\n      }\n    }\n\n    for (const key of this.addressMap.keys()) {\n      if (!subchannelAddresses.has(key)) {\n        this.addressMap.delete(key);\n      }\n    }\n\n    const childPolicy = load_balancer_1.getFirstUsableConfig(lbConfig.getChildPolicy(), true);\n    this.childBalancer.updateAddressList(addressList, childPolicy, attributes);\n\n    if (this.latestConfig === null || this.latestConfig.getIntervalMs() !== lbConfig.getIntervalMs()) {\n      clearInterval(this.ejectionTimer);\n      this.ejectionTimer = setInterval(() => this.runChecks(), lbConfig.getIntervalMs());\n    }\n\n    this.latestConfig = lbConfig;\n  }\n\n  exitIdle() {\n    this.childBalancer.exitIdle();\n  }\n\n  resetBackoff() {\n    this.childBalancer.resetBackoff();\n  }\n\n  destroy() {\n    this.childBalancer.destroy();\n  }\n\n  getTypeName() {\n    return TYPE_NAME;\n  }\n\n}\n\nexports.OutlierDetectionLoadBalancer = OutlierDetectionLoadBalancer;\n\nfunction setup() {\n  if (OUTLIER_DETECTION_ENABLED) {\n    experimental_1.registerLoadBalancerType(TYPE_NAME, OutlierDetectionLoadBalancer, OutlierDetectionLoadBalancingConfig);\n  }\n}\n\nexports.setup = setup;","map":{"version":3,"mappings":"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","names":["TYPE_NAME","OUTLIER_DETECTION_ENABLED","process","env","GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION","defaultSuccessRateEjectionConfig","stdev_factor","enforcement_percentage","minimum_hosts","request_volume","defaultFailurePercentageEjectionConfig","threshold","validateFieldType","obj","fieldName","expectedType","objectName","fullFieldName","Error","validatePositiveDuration","duration_1","seconds","nanos","validatePercentage","OutlierDetectionLoadBalancingConfig","constructor","intervalMs","baseEjectionTimeMs","maxEjectionTimeMs","maxEjectionPercent","successRateEjection","failurePercentageEjection","childPolicy","Object","getLoadBalancerName","toJsonObject","interval","base_ejection_time","max_ejection_time","max_ejection_percent","success_rate_ejection","failure_percentage_ejection","child_policy","map","policy","getIntervalMs","getBaseEjectionTimeMs","getMaxEjectionTimeMs","getMaxEjectionPercent","getSuccessRateEjectionConfig","getFailurePercentageEjectionConfig","getChildPolicy","copyWithChildPolicy","createFromJson","_a","load_balancer_1","exports","OutlierDetectionSubchannelWrapper","subchannel_interface_1","childSubchannel","mapEntry","connectivity_state_1","IDLE","addConnectivityStateListener","subchannel","previousState","newState","childSubchannelState","ejected","listener","stateListeners","push","removeConnectivityStateListener","listenerIndex","indexOf","splice","ref","child","refCount","unref","index","subchannelWrappers","eject","TRANSIENT_FAILURE","uneject","getMapEntry","getWrappedSubchannel","createEmptyBucket","success","failure","CallCounter","addSuccess","activeBucket","addFailure","switchBuckets","inactiveBucket","getLastSuccesses","getLastFailures","OutlierDetectionCounterFilter","filter_1","callCounter","receiveTrailers","status","code","constants_1","OK","OutlierDetectionCounterFilterFactory","createFilter","callStream","OutlierDetectionPicker","wrappedPicker","pick","pickArgs","wrappedPick","pickResultType","picker_1","COMPLETE","subchannelWrapper","extraFilterFactories","counter","OutlierDetectionLoadBalancer","channelControlHelper","Map","childBalancer","load_balancer_child_handler_1","experimental_1","createSubchannel","subchannelAddress","subchannelArgs","originalSubchannel","addressMap","get","subchannel_address_1","updateState","connectivityState","picker","READY","ejectionTimer","setInterval","clearInterval","getCurrentEjectionPercent","ejectionCount","values","currentEjectionTimestamp","size","runSuccessRateCheck","ejectionTimestamp","latestConfig","successRateConfig","targetRequestVolume","addresesWithTargetVolume","successRates","successes","failures","successRateMean","reduce","a","b","successRateVariance","rate","deviation","successRateStdev","Math","sqrt","ejectionThreshold","successRate","randomNumber","random","runFailurePercentageCheck","failurePercentageConfig","failurePercentage","Date","ejectionTimeMultiplier","runChecks","returnTime","getTime","setMilliseconds","getMilliseconds","min","max","updateAddressList","addressList","lbConfig","attributes","subchannelAddresses","Set","address","add","has","set","key","keys","delete","exitIdle","resetBackoff","destroy","getTypeName","setup"],"sources":["C:\\Users\\binel\\OneDrive\\Desktop\\Today\\Udemy\\iProfiler\\iProfiler\\iprofiler\\node_modules\\@grpc\\grpc-js\\src\\load-balancer-outlier-detection.ts"],"sourcesContent":["/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { ChannelOptions, connectivityState, StatusObject } from \".\";\nimport { Call } from \"./call-stream\";\nimport { ConnectivityState } from \"./connectivity-state\";\nimport { Status } from \"./constants\";\nimport { durationToMs, isDuration, msToDuration } from \"./duration\";\nimport { ChannelControlHelper, createChildChannelControlHelper, registerLoadBalancerType } from \"./experimental\";\nimport { BaseFilter, Filter, FilterFactory } from \"./filter\";\nimport { getFirstUsableConfig, LoadBalancer, LoadBalancingConfig, validateLoadBalancingConfig } from \"./load-balancer\";\nimport { ChildLoadBalancerHandler } from \"./load-balancer-child-handler\";\nimport { PickArgs, Picker, PickResult, PickResultType, QueuePicker, UnavailablePicker } from \"./picker\";\nimport { Subchannel } from \"./subchannel\";\nimport { SubchannelAddress, subchannelAddressToString } from \"./subchannel-address\";\nimport { BaseSubchannelWrapper, ConnectivityStateListener, SubchannelInterface } from \"./subchannel-interface\";\n\n\nconst TYPE_NAME = 'outlier_detection';\n\nconst OUTLIER_DETECTION_ENABLED = process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION === 'true';\n\nexport interface SuccessRateEjectionConfig {\n  readonly stdev_factor: number;\n  readonly enforcement_percentage: number;\n  readonly minimum_hosts: number;\n  readonly request_volume: number;\n}\n\nexport interface FailurePercentageEjectionConfig {\n  readonly threshold: number;\n  readonly enforcement_percentage: number;\n  readonly minimum_hosts: number;\n  readonly request_volume: number;\n}\n\nconst defaultSuccessRateEjectionConfig: SuccessRateEjectionConfig = {\n  stdev_factor: 1900,\n  enforcement_percentage: 100,\n  minimum_hosts: 5,\n  request_volume: 100\n};\n\nconst defaultFailurePercentageEjectionConfig: FailurePercentageEjectionConfig = {\n  threshold: 85,\n  enforcement_percentage: 100,\n  minimum_hosts: 5,\n  request_volume: 50\n}\n\ntype TypeofValues = 'object' | 'boolean' | 'function' | 'number' | 'string' | 'undefined';\n\nfunction validateFieldType(obj: any, fieldName: string, expectedType: TypeofValues, objectName?: string) {\n  if (fieldName in obj && typeof obj[fieldName] !== expectedType) {\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n    throw new Error(`outlier detection config ${fullFieldName} parse error: expected ${expectedType}, got ${typeof obj[fieldName]}`);\n  }\n}\n\nfunction validatePositiveDuration(obj: any, fieldName: string, objectName?: string) {\n  const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n  if (fieldName in obj) {\n    if (!isDuration(obj[fieldName])) {\n      throw new Error(`outlier detection config ${fullFieldName} parse error: expected Duration, got ${typeof obj[fieldName]}`);\n    }\n    if (!(obj[fieldName].seconds >= 0 && obj[fieldName].seconds <= 315_576_000_000 && obj[fieldName].nanos >= 0 && obj[fieldName].nanos <= 999_999_999)) {\n      throw new Error(`outlier detection config ${fullFieldName} parse error: values out of range for non-negative Duaration`);\n    }\n  }\n}\n\nfunction validatePercentage(obj: any, fieldName: string, objectName?: string) {\n  const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n  validateFieldType(obj, fieldName, 'number', objectName);\n  if (fieldName in obj && !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) {\n    throw new Error(`outlier detection config ${fullFieldName} parse error: value out of range for percentage (0-100)`);\n  }\n}\n\nexport class OutlierDetectionLoadBalancingConfig implements LoadBalancingConfig {\n  private readonly intervalMs: number;\n  private readonly baseEjectionTimeMs: number;\n  private readonly maxEjectionTimeMs: number;\n  private readonly maxEjectionPercent: number;\n  private readonly successRateEjection: SuccessRateEjectionConfig | null;\n  private readonly failurePercentageEjection: FailurePercentageEjectionConfig | null;\n\n  constructor(\n    intervalMs: number | null,\n    baseEjectionTimeMs: number | null,\n    maxEjectionTimeMs: number | null,\n    maxEjectionPercent: number | null,\n    successRateEjection: Partial<SuccessRateEjectionConfig> | null,\n    failurePercentageEjection: Partial<FailurePercentageEjectionConfig> | null,\n    private readonly childPolicy: LoadBalancingConfig[]\n  ) {\n    this.intervalMs = intervalMs ?? 10_000;\n    this.baseEjectionTimeMs = baseEjectionTimeMs ?? 30_000;\n    this.maxEjectionTimeMs = maxEjectionTimeMs ?? 300_000;\n    this.maxEjectionPercent = maxEjectionPercent ?? 10;\n    this.successRateEjection = successRateEjection ? {...defaultSuccessRateEjectionConfig, ...successRateEjection} : null;\n    this.failurePercentageEjection = failurePercentageEjection ? {...defaultFailurePercentageEjectionConfig, ...failurePercentageEjection}: null;\n  }\n  getLoadBalancerName(): string {\n    return TYPE_NAME;\n  }\n  toJsonObject(): object {\n    return {\n      interval: msToDuration(this.intervalMs),\n      base_ejection_time: msToDuration(this.baseEjectionTimeMs),\n      max_ejection_time: msToDuration(this.maxEjectionTimeMs),\n      max_ejection_percent: this.maxEjectionPercent,\n      success_rate_ejection: this.successRateEjection,\n      failure_percentage_ejection: this.failurePercentageEjection,\n      child_policy: this.childPolicy.map(policy => policy.toJsonObject())\n    };\n  }\n\n  getIntervalMs(): number {\n    return this.intervalMs;\n  }\n  getBaseEjectionTimeMs(): number {\n    return this.baseEjectionTimeMs;\n  }\n  getMaxEjectionTimeMs(): number {\n    return this.maxEjectionTimeMs;\n  }\n  getMaxEjectionPercent(): number {\n    return this.maxEjectionPercent;\n  }\n  getSuccessRateEjectionConfig(): SuccessRateEjectionConfig | null {\n    return this.successRateEjection;\n  }\n  getFailurePercentageEjectionConfig(): FailurePercentageEjectionConfig | null {\n    return this.failurePercentageEjection;\n  }\n  getChildPolicy(): LoadBalancingConfig[] {\n    return this.childPolicy;\n  }\n\n  copyWithChildPolicy(childPolicy: LoadBalancingConfig[]): OutlierDetectionLoadBalancingConfig {\n    return new OutlierDetectionLoadBalancingConfig(this.intervalMs, this.baseEjectionTimeMs, this.maxEjectionTimeMs, this.maxEjectionPercent, this.successRateEjection, this.failurePercentageEjection, childPolicy);\n  }\n\n  static createFromJson(obj: any): OutlierDetectionLoadBalancingConfig {\n    validatePositiveDuration(obj, 'interval');\n    validatePositiveDuration(obj, 'base_ejection_time');\n    validatePositiveDuration(obj, 'max_ejection_time');\n    validatePercentage(obj, 'max_ejection_percent');\n    if ('success_rate_ejection' in obj) {\n      if (typeof obj.success_rate_ejection !== 'object') {\n        throw new Error('outlier detection config success_rate_ejection must be an object');\n      }\n      validateFieldType(obj.success_rate_ejection, 'stdev_factor', 'number', 'success_rate_ejection');\n      validatePercentage(obj.success_rate_ejection, 'enforcement_percentage', 'success_rate_ejection');\n      validateFieldType(obj.success_rate_ejection, 'minimum_hosts', 'number', 'success_rate_ejection');\n      validateFieldType(obj.success_rate_ejection, 'request_volume', 'number', 'success_rate_ejection');\n    }\n    if ('failure_percentage_ejection' in obj) {\n      if (typeof obj.failure_percentage_ejection !== 'object') {\n        throw new Error('outlier detection config failure_percentage_ejection must be an object');\n      }\n      validatePercentage(obj.failure_percentage_ejection, 'threshold', 'failure_percentage_ejection');\n      validatePercentage(obj.failure_percentage_ejection, 'enforcement_percentage', 'failure_percentage_ejection');\n      validateFieldType(obj.failure_percentage_ejection, 'minimum_hosts', 'number', 'failure_percentage_ejection');\n      validateFieldType(obj.failure_percentage_ejection, 'request_volume', 'number', 'failure_percentage_ejection');\n    }\n\n    return new OutlierDetectionLoadBalancingConfig(\n      obj.interval ? durationToMs(obj.interval) : null,\n      obj.base_ejection_time ? durationToMs(obj.base_ejection_time) : null,\n      obj.max_ejection_time ? durationToMs(obj.max_ejection_time) : null,\n      obj.max_ejection_percent ?? null,\n      obj.success_rate_ejection,\n      obj.failure_percentage_ejection,\n      obj.child_policy.map(validateLoadBalancingConfig)\n    );\n  }\n}\n\nclass OutlierDetectionSubchannelWrapper extends BaseSubchannelWrapper implements SubchannelInterface {\n  private childSubchannelState: ConnectivityState = ConnectivityState.IDLE;\n  private stateListeners: ConnectivityStateListener[] = [];\n  private ejected: boolean = false;\n  private refCount: number = 0;\n  constructor(childSubchannel: SubchannelInterface, private mapEntry?: MapEntry) {\n    super(childSubchannel);\n    childSubchannel.addConnectivityStateListener((subchannel, previousState, newState) => {\n      this.childSubchannelState = newState;\n      if (!this.ejected) {\n        for (const listener of this.stateListeners) {\n          listener(this, previousState, newState);\n        }\n      }\n    });\n  }\n\n  /**\n   * Add a listener function to be called whenever the wrapper's\n   * connectivity state changes.\n   * @param listener\n   */\n  addConnectivityStateListener(listener: ConnectivityStateListener) {\n    this.stateListeners.push(listener);\n  }\n\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n  removeConnectivityStateListener(listener: ConnectivityStateListener) {\n    const listenerIndex = this.stateListeners.indexOf(listener);\n    if (listenerIndex > -1) {\n      this.stateListeners.splice(listenerIndex, 1);\n    }\n  }\n\n  ref() {\n    this.child.ref();\n    this.refCount += 1;\n  }\n\n  unref() {\n    this.child.unref();\n    this.refCount -= 1;\n    if (this.refCount <= 0) {\n      if (this.mapEntry) {\n        const index = this.mapEntry.subchannelWrappers.indexOf(this);\n        if (index >= 0) {\n          this.mapEntry.subchannelWrappers.splice(index, 1);\n        }\n      }\n    }\n  }\n\n  eject() {\n    this.ejected = true;\n    for (const listener of this.stateListeners) {\n      listener(this, this.childSubchannelState, ConnectivityState.TRANSIENT_FAILURE);\n    }\n  }\n\n  uneject() {\n    this.ejected = false;\n    for (const listener of this.stateListeners) {\n      listener(this, ConnectivityState.TRANSIENT_FAILURE, this.childSubchannelState);\n    }\n  }\n\n  getMapEntry(): MapEntry | undefined {\n    return this.mapEntry;\n  }\n\n  getWrappedSubchannel(): SubchannelInterface {\n    return this.child;\n  }\n}\n\ninterface CallCountBucket {\n  success: number;\n  failure: number;\n}\n\nfunction createEmptyBucket(): CallCountBucket {\n  return {\n    success: 0,\n    failure: 0\n  }\n}\n\nclass CallCounter {\n  private activeBucket: CallCountBucket = createEmptyBucket();\n  private inactiveBucket: CallCountBucket = createEmptyBucket();\n  addSuccess() {\n    this.activeBucket.success += 1;\n  }\n  addFailure() {\n    this.activeBucket.failure += 1;\n  }\n  switchBuckets() {\n    this.inactiveBucket = this.activeBucket;\n    this.activeBucket = createEmptyBucket();\n  }\n  getLastSuccesses() {\n    return this.inactiveBucket.success;\n  }\n  getLastFailures() {\n    return this.inactiveBucket.failure;\n  }\n}\n\ninterface MapEntry {\n  counter: CallCounter;\n  currentEjectionTimestamp: Date | null;\n  ejectionTimeMultiplier: number;\n  subchannelWrappers: OutlierDetectionSubchannelWrapper[];\n}\n\nclass OutlierDetectionCounterFilter extends BaseFilter implements Filter {\n  constructor(private callCounter: CallCounter) {\n    super();\n  }\n  receiveTrailers(status: StatusObject): StatusObject {\n    if (status.code === Status.OK) {\n      this.callCounter.addSuccess();\n    } else {\n      this.callCounter.addFailure();\n    }\n    return status;\n  }\n}\n\nclass OutlierDetectionCounterFilterFactory implements FilterFactory<OutlierDetectionCounterFilter> {\n  constructor(private callCounter: CallCounter) {}\n  createFilter(callStream: Call): OutlierDetectionCounterFilter {\n    return new OutlierDetectionCounterFilter(this.callCounter);\n  }\n\n}\n\nclass OutlierDetectionPicker implements Picker {\n  constructor(private wrappedPicker: Picker) {}\n  pick(pickArgs: PickArgs): PickResult {\n    const wrappedPick = this.wrappedPicker.pick(pickArgs);\n    if (wrappedPick.pickResultType === PickResultType.COMPLETE) {\n      const subchannelWrapper = wrappedPick.subchannel as OutlierDetectionSubchannelWrapper;\n      const mapEntry = subchannelWrapper.getMapEntry();\n      if (mapEntry) {\n        return {\n          ...wrappedPick,\n          subchannel: subchannelWrapper.getWrappedSubchannel(),\n          extraFilterFactories: [...wrappedPick.extraFilterFactories, new OutlierDetectionCounterFilterFactory(mapEntry.counter)]\n        };\n      } else {\n        return wrappedPick;\n      }\n    } else {\n      return wrappedPick;\n    }\n  }\n\n}\n\nexport class OutlierDetectionLoadBalancer implements LoadBalancer {\n  private childBalancer: ChildLoadBalancerHandler;\n  private addressMap: Map<string, MapEntry> = new Map<string, MapEntry>();\n  private latestConfig: OutlierDetectionLoadBalancingConfig | null = null;\n  private ejectionTimer: NodeJS.Timer;\n\n  constructor(channelControlHelper: ChannelControlHelper) {\n    this.childBalancer = new ChildLoadBalancerHandler(createChildChannelControlHelper(channelControlHelper, {\n      createSubchannel: (subchannelAddress: SubchannelAddress, subchannelArgs: ChannelOptions) => {\n        const originalSubchannel = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n        const mapEntry = this.addressMap.get(subchannelAddressToString(subchannelAddress));\n        const subchannelWrapper = new OutlierDetectionSubchannelWrapper(originalSubchannel, mapEntry);\n        mapEntry?.subchannelWrappers.push(subchannelWrapper);\n        return subchannelWrapper;\n      },\n      updateState: (connectivityState: ConnectivityState, picker: Picker) => {\n        if (connectivityState === ConnectivityState.READY) {\n          channelControlHelper.updateState(connectivityState, new OutlierDetectionPicker(picker));\n        } else {\n          channelControlHelper.updateState(connectivityState, picker);\n        }\n      }\n    }));\n    this.ejectionTimer = setInterval(() => {}, 0);\n    clearInterval(this.ejectionTimer);\n  }\n\n  private getCurrentEjectionPercent() {\n    let ejectionCount = 0;\n    for (const mapEntry of this.addressMap.values()) {\n      if (mapEntry.currentEjectionTimestamp !== null) {\n        ejectionCount += 1;\n      }\n    }\n    return (ejectionCount * 100) / this.addressMap.size;\n  }\n\n  private runSuccessRateCheck(ejectionTimestamp: Date) {\n    if (!this.latestConfig) {\n      return;\n    }\n    const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();\n    if (!successRateConfig) {\n      return;\n    }\n    // Step 1\n    const targetRequestVolume = successRateConfig.request_volume;\n    let addresesWithTargetVolume = 0;\n    const successRates: number[] = []\n    for (const mapEntry of this.addressMap.values()) {\n      const successes = mapEntry.counter.getLastSuccesses();\n      const failures = mapEntry.counter.getLastFailures();\n      if (successes + failures >= targetRequestVolume) {\n        addresesWithTargetVolume += 1;\n        successRates.push(successes/(successes + failures));\n      }\n    }\n    if (addresesWithTargetVolume < successRateConfig.minimum_hosts) {\n      return;\n    }\n\n    // Step 2\n    const successRateMean = successRates.reduce((a, b) => a + b);\n    let successRateVariance = 0;\n    for (const rate of successRates) {\n      const deviation = rate - successRateMean;\n      successRateVariance += deviation * deviation;\n    }\n    const successRateStdev = Math.sqrt(successRateVariance);\n    const ejectionThreshold = successRateMean - successRateStdev * (successRateConfig.stdev_factor / 1000);\n\n    // Step 3\n    for (const mapEntry of this.addressMap.values()) {\n      // Step 3.i\n      if (this.getCurrentEjectionPercent() > this.latestConfig.getMaxEjectionPercent()) {\n        break;\n      }\n      // Step 3.ii\n      const successes = mapEntry.counter.getLastSuccesses();\n      const failures = mapEntry.counter.getLastFailures();\n      if (successes + failures < targetRequestVolume) {\n        continue;\n      }\n      // Step 3.iii\n      const successRate = successes / (successes + failures);\n      if (successRate < ejectionThreshold) {\n        const randomNumber = Math.random() * 100;\n        if (randomNumber < successRateConfig.enforcement_percentage) {\n          this.eject(mapEntry, ejectionTimestamp);\n        }\n      }\n    }\n  }\n\n  private runFailurePercentageCheck(ejectionTimestamp: Date) {\n    if (!this.latestConfig) {\n      return;\n    }\n    const failurePercentageConfig = this.latestConfig.getFailurePercentageEjectionConfig()\n    if (!failurePercentageConfig) {\n      return;\n    }\n    // Step 1\n    if (this.addressMap.size < failurePercentageConfig.minimum_hosts) {\n      return;\n    }\n    \n    // Step 2\n    for (const mapEntry of this.addressMap.values()) {\n      // Step 2.i\n      if (this.getCurrentEjectionPercent() > this.latestConfig.getMaxEjectionPercent()) {\n        break;\n      }\n      // Step 2.ii\n      const successes = mapEntry.counter.getLastSuccesses();\n      const failures = mapEntry.counter.getLastFailures();\n      if (successes + failures < failurePercentageConfig.request_volume) {\n        continue;\n      }\n      // Step 2.iii\n      const failurePercentage = (failures * 100) / (failures + successes);\n      if (failurePercentage > failurePercentageConfig.threshold) {\n        const randomNumber = Math.random() * 100;\n        if (randomNumber < failurePercentageConfig.enforcement_percentage) {\n          this.eject(mapEntry, ejectionTimestamp);\n        }\n      }\n    }\n  }\n\n  private eject(mapEntry: MapEntry, ejectionTimestamp: Date) {\n    mapEntry.currentEjectionTimestamp = new Date();\n    mapEntry.ejectionTimeMultiplier += 1;\n    for (const subchannelWrapper of mapEntry.subchannelWrappers) {\n      subchannelWrapper.eject();\n    }\n  }\n\n  private uneject(mapEntry: MapEntry) {\n    mapEntry.currentEjectionTimestamp = null;\n    for (const subchannelWrapper of mapEntry.subchannelWrappers) {\n      subchannelWrapper.uneject();\n    }\n  }\n\n  private runChecks() {\n    const ejectionTimestamp = new Date();\n\n    for (const mapEntry of this.addressMap.values()) {\n      mapEntry.counter.switchBuckets();\n    }\n\n    if (!this.latestConfig) {\n      return;\n    }\n\n    this.runSuccessRateCheck(ejectionTimestamp);\n    this.runFailurePercentageCheck(ejectionTimestamp);\n\n    for (const mapEntry of this.addressMap.values()) {\n      if (mapEntry.currentEjectionTimestamp === null) {\n        if (mapEntry.ejectionTimeMultiplier > 0) {\n          mapEntry.ejectionTimeMultiplier -= 1;\n        }\n      } else {\n        const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();\n        const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();\n        const returnTime = new Date(mapEntry.currentEjectionTimestamp.getTime());\n        returnTime.setMilliseconds(returnTime.getMilliseconds() + Math.min(baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier, Math.max(baseEjectionTimeMs, maxEjectionTimeMs)));\n        if (returnTime < new Date()) {\n          this.uneject(mapEntry);\n        }\n      }\n    }\n  }\n\n  updateAddressList(addressList: SubchannelAddress[], lbConfig: LoadBalancingConfig, attributes: { [key: string]: unknown; }): void {\n    if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) {\n      return;\n    }\n    const subchannelAddresses = new Set<string>();\n    for (const address of addressList) {\n      subchannelAddresses.add(subchannelAddressToString(address));\n    }\n    for (const address of subchannelAddresses) {\n      if (!this.addressMap.has(address)) {\n        this.addressMap.set(address, {\n          counter: new CallCounter(),\n          currentEjectionTimestamp: null,\n          ejectionTimeMultiplier: 0,\n          subchannelWrappers: []\n        });\n      }\n    }\n    for (const key of this.addressMap.keys()) {\n      if (!subchannelAddresses.has(key)) {\n        this.addressMap.delete(key);\n      }\n    }\n    const childPolicy: LoadBalancingConfig = getFirstUsableConfig(\n      lbConfig.getChildPolicy(),\n      true\n    );\n    this.childBalancer.updateAddressList(addressList, childPolicy, attributes);\n\n    if (this.latestConfig === null || this.latestConfig.getIntervalMs() !== lbConfig.getIntervalMs()) {\n      clearInterval(this.ejectionTimer);\n      this.ejectionTimer = setInterval(() => this.runChecks(), lbConfig.getIntervalMs());\n    }\n    this.latestConfig = lbConfig;\n  }\n  exitIdle(): void {\n    this.childBalancer.exitIdle();\n  }\n  resetBackoff(): void {\n    this.childBalancer.resetBackoff();\n  }\n  destroy(): void {\n    this.childBalancer.destroy();\n  }\n  getTypeName(): string {\n    return TYPE_NAME;\n  }\n}\n\nexport function setup() {\n  if (OUTLIER_DETECTION_ENABLED) {\n    registerLoadBalancerType(TYPE_NAME, OutlierDetectionLoadBalancer, OutlierDetectionLoadBalancingConfig);\n  }\n}"]},"metadata":{},"sourceType":"script"}