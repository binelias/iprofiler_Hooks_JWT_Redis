{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Metadata = void 0;\n\nconst logging_1 = require(\"./logging\");\n\nconst constants_1 = require(\"./constants\");\n\nconst LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;\nconst LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;\n\nfunction isLegalKey(key) {\n  return LEGAL_KEY_REGEX.test(key);\n}\n\nfunction isLegalNonBinaryValue(value) {\n  return LEGAL_NON_BINARY_VALUE_REGEX.test(value);\n}\n\nfunction isBinaryKey(key) {\n  return key.endsWith('-bin');\n}\n\nfunction isCustomMetadata(key) {\n  return !key.startsWith('grpc-');\n}\n\nfunction normalizeKey(key) {\n  return key.toLowerCase();\n}\n\nfunction validate(key, value) {\n  if (!isLegalKey(key)) {\n    throw new Error('Metadata key \"' + key + '\" contains illegal characters');\n  }\n\n  if (value !== null && value !== undefined) {\n    if (isBinaryKey(key)) {\n      if (!(value instanceof Buffer)) {\n        throw new Error(\"keys that end with '-bin' must have Buffer values\");\n      }\n    } else {\n      if (value instanceof Buffer) {\n        throw new Error(\"keys that don't end with '-bin' must have String values\");\n      }\n\n      if (!isLegalNonBinaryValue(value)) {\n        throw new Error('Metadata string value \"' + value + '\" contains illegal characters');\n      }\n    }\n  }\n}\n/**\n * A class for storing metadata. Keys are normalized to lowercase ASCII.\n */\n\n\nclass Metadata {\n  constructor(options) {\n    this.internalRepr = new Map();\n\n    if (options === undefined) {\n      this.options = {};\n    } else {\n      this.options = options;\n    }\n  }\n  /**\n   * Sets the given value for the given key by replacing any other values\n   * associated with that key. Normalizes the key.\n   * @param key The key to whose value should be set.\n   * @param value The value to set. Must be a buffer if and only\n   *   if the normalized key ends with '-bin'.\n   */\n\n\n  set(key, value) {\n    key = normalizeKey(key);\n    validate(key, value);\n    this.internalRepr.set(key, [value]);\n  }\n  /**\n   * Adds the given value for the given key by appending to a list of previous\n   * values associated with that key. Normalizes the key.\n   * @param key The key for which a new value should be appended.\n   * @param value The value to add. Must be a buffer if and only\n   *   if the normalized key ends with '-bin'.\n   */\n\n\n  add(key, value) {\n    key = normalizeKey(key);\n    validate(key, value);\n    const existingValue = this.internalRepr.get(key);\n\n    if (existingValue === undefined) {\n      this.internalRepr.set(key, [value]);\n    } else {\n      existingValue.push(value);\n    }\n  }\n  /**\n   * Removes the given key and any associated values. Normalizes the key.\n   * @param key The key whose values should be removed.\n   */\n\n\n  remove(key) {\n    key = normalizeKey(key);\n    validate(key);\n    this.internalRepr.delete(key);\n  }\n  /**\n   * Gets a list of all values associated with the key. Normalizes the key.\n   * @param key The key whose value should be retrieved.\n   * @return A list of values associated with the given key.\n   */\n\n\n  get(key) {\n    key = normalizeKey(key);\n    validate(key);\n    return this.internalRepr.get(key) || [];\n  }\n  /**\n   * Gets a plain object mapping each key to the first value associated with it.\n   * This reflects the most common way that people will want to see metadata.\n   * @return A key/value mapping of the metadata.\n   */\n\n\n  getMap() {\n    const result = {};\n    this.internalRepr.forEach((values, key) => {\n      if (values.length > 0) {\n        const v = values[0];\n        result[key] = v instanceof Buffer ? v.slice() : v;\n      }\n    });\n    return result;\n  }\n  /**\n   * Clones the metadata object.\n   * @return The newly cloned object.\n   */\n\n\n  clone() {\n    const newMetadata = new Metadata(this.options);\n    const newInternalRepr = newMetadata.internalRepr;\n    this.internalRepr.forEach((value, key) => {\n      const clonedValue = value.map(v => {\n        if (v instanceof Buffer) {\n          return Buffer.from(v);\n        } else {\n          return v;\n        }\n      });\n      newInternalRepr.set(key, clonedValue);\n    });\n    return newMetadata;\n  }\n  /**\n   * Merges all key-value pairs from a given Metadata object into this one.\n   * If both this object and the given object have values in the same key,\n   * values from the other Metadata object will be appended to this object's\n   * values.\n   * @param other A Metadata object.\n   */\n\n\n  merge(other) {\n    other.internalRepr.forEach((values, key) => {\n      const mergedValue = (this.internalRepr.get(key) || []).concat(values);\n      this.internalRepr.set(key, mergedValue);\n    });\n  }\n\n  setOptions(options) {\n    this.options = options;\n  }\n\n  getOptions() {\n    return this.options;\n  }\n  /**\n   * Creates an OutgoingHttpHeaders object that can be used with the http2 API.\n   */\n\n\n  toHttp2Headers() {\n    // NOTE: Node <8.9 formats http2 headers incorrectly.\n    const result = {};\n    this.internalRepr.forEach((values, key) => {\n      // We assume that the user's interaction with this object is limited to\n      // through its public API (i.e. keys and values are already validated).\n      result[key] = values.map(value => {\n        if (value instanceof Buffer) {\n          return value.toString('base64');\n        } else {\n          return value;\n        }\n      });\n    });\n    return result;\n  } // For compatibility with the other Metadata implementation\n\n\n  _getCoreRepresentation() {\n    return this.internalRepr;\n  }\n  /**\n   * This modifies the behavior of JSON.stringify to show an object\n   * representation of the metadata map.\n   */\n\n\n  toJSON() {\n    const result = {};\n\n    for (const [key, values] of this.internalRepr.entries()) {\n      result[key] = values;\n    }\n\n    return result;\n  }\n  /**\n   * Returns a new Metadata object based fields in a given IncomingHttpHeaders\n   * object.\n   * @param headers An IncomingHttpHeaders object.\n   */\n\n\n  static fromHttp2Headers(headers) {\n    const result = new Metadata();\n    Object.keys(headers).forEach(key => {\n      // Reserved headers (beginning with `:`) are not valid keys.\n      if (key.charAt(0) === ':') {\n        return;\n      }\n\n      const values = headers[key];\n\n      try {\n        if (isBinaryKey(key)) {\n          if (Array.isArray(values)) {\n            values.forEach(value => {\n              result.add(key, Buffer.from(value, 'base64'));\n            });\n          } else if (values !== undefined) {\n            if (isCustomMetadata(key)) {\n              values.split(',').forEach(v => {\n                result.add(key, Buffer.from(v.trim(), 'base64'));\n              });\n            } else {\n              result.add(key, Buffer.from(values, 'base64'));\n            }\n          }\n        } else {\n          if (Array.isArray(values)) {\n            values.forEach(value => {\n              result.add(key, value);\n            });\n          } else if (values !== undefined) {\n            result.add(key, values);\n          }\n        }\n      } catch (error) {\n        const message = `Failed to add metadata entry ${key}: ${values}. ${error.message}. For more information see https://github.com/grpc/grpc-node/issues/1173`;\n        logging_1.log(constants_1.LogVerbosity.ERROR, message);\n      }\n    });\n    return result;\n  }\n\n}\n\nexports.Metadata = Metadata;","map":{"version":3,"mappings":"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","names":["LEGAL_KEY_REGEX","LEGAL_NON_BINARY_VALUE_REGEX","isLegalKey","key","test","isLegalNonBinaryValue","value","isBinaryKey","endsWith","isCustomMetadata","startsWith","normalizeKey","toLowerCase","validate","Error","undefined","Buffer","Metadata","constructor","options","Map","set","internalRepr","add","existingValue","get","push","remove","delete","getMap","result","forEach","values","length","v","slice","clone","newMetadata","newInternalRepr","clonedValue","map","from","merge","other","mergedValue","concat","setOptions","getOptions","toHttp2Headers","toString","_getCoreRepresentation","toJSON","entries","fromHttp2Headers","headers","Object","keys","charAt","Array","isArray","split","trim","error","message","logging_1","constants_1","ERROR","exports"],"sources":["C:\\Users\\binel\\OneDrive\\Desktop\\Today\\Udemy\\iProfiler\\iProfiler\\iprofiler\\node_modules\\@grpc\\grpc-js\\src\\metadata.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as http2 from 'http2';\nimport { log } from './logging';\nimport { LogVerbosity } from './constants';\nconst LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;\nconst LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;\n\nexport type MetadataValue = string | Buffer;\nexport type MetadataObject = Map<string, MetadataValue[]>;\n\nfunction isLegalKey(key: string): boolean {\n  return LEGAL_KEY_REGEX.test(key);\n}\n\nfunction isLegalNonBinaryValue(value: string): boolean {\n  return LEGAL_NON_BINARY_VALUE_REGEX.test(value);\n}\n\nfunction isBinaryKey(key: string): boolean {\n  return key.endsWith('-bin');\n}\n\nfunction isCustomMetadata(key: string): boolean {\n  return !key.startsWith('grpc-');\n}\n\nfunction normalizeKey(key: string): string {\n  return key.toLowerCase();\n}\n\nfunction validate(key: string, value?: MetadataValue): void {\n  if (!isLegalKey(key)) {\n    throw new Error('Metadata key \"' + key + '\" contains illegal characters');\n  }\n  if (value !== null && value !== undefined) {\n    if (isBinaryKey(key)) {\n      if (!(value instanceof Buffer)) {\n        throw new Error(\"keys that end with '-bin' must have Buffer values\");\n      }\n    } else {\n      if (value instanceof Buffer) {\n        throw new Error(\n          \"keys that don't end with '-bin' must have String values\"\n        );\n      }\n      if (!isLegalNonBinaryValue(value)) {\n        throw new Error(\n          'Metadata string value \"' + value + '\" contains illegal characters'\n        );\n      }\n    }\n  }\n}\n\nexport interface MetadataOptions {\n  /* Signal that the request is idempotent. Defaults to false */\n  idempotentRequest?: boolean;\n  /* Signal that the call should not return UNAVAILABLE before it has\n   * started. Defaults to false. */\n  waitForReady?: boolean;\n  /* Signal that the call is cacheable. GRPC is free to use GET verb.\n   * Defaults to false */\n  cacheableRequest?: boolean;\n  /* Signal that the initial metadata should be corked. Defaults to false. */\n  corked?: boolean;\n}\n\n/**\n * A class for storing metadata. Keys are normalized to lowercase ASCII.\n */\nexport class Metadata {\n  protected internalRepr: MetadataObject = new Map<string, MetadataValue[]>();\n  private options: MetadataOptions;\n\n  constructor(options?: MetadataOptions) {\n    if (options === undefined) {\n      this.options = {};\n    } else {\n      this.options = options;\n    }\n  }\n\n  /**\n   * Sets the given value for the given key by replacing any other values\n   * associated with that key. Normalizes the key.\n   * @param key The key to whose value should be set.\n   * @param value The value to set. Must be a buffer if and only\n   *   if the normalized key ends with '-bin'.\n   */\n  set(key: string, value: MetadataValue): void {\n    key = normalizeKey(key);\n    validate(key, value);\n    this.internalRepr.set(key, [value]);\n  }\n\n  /**\n   * Adds the given value for the given key by appending to a list of previous\n   * values associated with that key. Normalizes the key.\n   * @param key The key for which a new value should be appended.\n   * @param value The value to add. Must be a buffer if and only\n   *   if the normalized key ends with '-bin'.\n   */\n  add(key: string, value: MetadataValue): void {\n    key = normalizeKey(key);\n    validate(key, value);\n\n    const existingValue: MetadataValue[] | undefined = this.internalRepr.get(\n      key\n    );\n\n    if (existingValue === undefined) {\n      this.internalRepr.set(key, [value]);\n    } else {\n      existingValue.push(value);\n    }\n  }\n\n  /**\n   * Removes the given key and any associated values. Normalizes the key.\n   * @param key The key whose values should be removed.\n   */\n  remove(key: string): void {\n    key = normalizeKey(key);\n    validate(key);\n    this.internalRepr.delete(key);\n  }\n\n  /**\n   * Gets a list of all values associated with the key. Normalizes the key.\n   * @param key The key whose value should be retrieved.\n   * @return A list of values associated with the given key.\n   */\n  get(key: string): MetadataValue[] {\n    key = normalizeKey(key);\n    validate(key);\n    return this.internalRepr.get(key) || [];\n  }\n\n  /**\n   * Gets a plain object mapping each key to the first value associated with it.\n   * This reflects the most common way that people will want to see metadata.\n   * @return A key/value mapping of the metadata.\n   */\n  getMap(): { [key: string]: MetadataValue } {\n    const result: { [key: string]: MetadataValue } = {};\n\n    this.internalRepr.forEach((values, key) => {\n      if (values.length > 0) {\n        const v = values[0];\n        result[key] = v instanceof Buffer ? v.slice() : v;\n      }\n    });\n    return result;\n  }\n\n  /**\n   * Clones the metadata object.\n   * @return The newly cloned object.\n   */\n  clone(): Metadata {\n    const newMetadata = new Metadata(this.options);\n    const newInternalRepr = newMetadata.internalRepr;\n\n    this.internalRepr.forEach((value, key) => {\n      const clonedValue: MetadataValue[] = value.map((v) => {\n        if (v instanceof Buffer) {\n          return Buffer.from(v);\n        } else {\n          return v;\n        }\n      });\n\n      newInternalRepr.set(key, clonedValue);\n    });\n\n    return newMetadata;\n  }\n\n  /**\n   * Merges all key-value pairs from a given Metadata object into this one.\n   * If both this object and the given object have values in the same key,\n   * values from the other Metadata object will be appended to this object's\n   * values.\n   * @param other A Metadata object.\n   */\n  merge(other: Metadata): void {\n    other.internalRepr.forEach((values, key) => {\n      const mergedValue: MetadataValue[] = (\n        this.internalRepr.get(key) || []\n      ).concat(values);\n\n      this.internalRepr.set(key, mergedValue);\n    });\n  }\n\n  setOptions(options: MetadataOptions) {\n    this.options = options;\n  }\n\n  getOptions(): MetadataOptions {\n    return this.options;\n  }\n\n  /**\n   * Creates an OutgoingHttpHeaders object that can be used with the http2 API.\n   */\n  toHttp2Headers(): http2.OutgoingHttpHeaders {\n    // NOTE: Node <8.9 formats http2 headers incorrectly.\n    const result: http2.OutgoingHttpHeaders = {};\n    this.internalRepr.forEach((values, key) => {\n      // We assume that the user's interaction with this object is limited to\n      // through its public API (i.e. keys and values are already validated).\n      result[key] = values.map((value) => {\n        if (value instanceof Buffer) {\n          return value.toString('base64');\n        } else {\n          return value;\n        }\n      });\n    });\n    return result;\n  }\n\n  // For compatibility with the other Metadata implementation\n  private _getCoreRepresentation() {\n    return this.internalRepr;\n  }\n\n  /**\n   * This modifies the behavior of JSON.stringify to show an object\n   * representation of the metadata map.\n   */\n  toJSON() {\n    const result: { [key: string]: MetadataValue[] } = {};\n    for (const [key, values] of this.internalRepr.entries()) {\n      result[key] = values;\n    }\n    return result;\n  }\n\n  /**\n   * Returns a new Metadata object based fields in a given IncomingHttpHeaders\n   * object.\n   * @param headers An IncomingHttpHeaders object.\n   */\n  static fromHttp2Headers(headers: http2.IncomingHttpHeaders): Metadata {\n    const result = new Metadata();\n    Object.keys(headers).forEach((key) => {\n      // Reserved headers (beginning with `:`) are not valid keys.\n      if (key.charAt(0) === ':') {\n        return;\n      }\n\n      const values = headers[key];\n\n      try {\n        if (isBinaryKey(key)) {\n          if (Array.isArray(values)) {\n            values.forEach((value) => {\n              result.add(key, Buffer.from(value, 'base64'));\n            });\n          } else if (values !== undefined) {\n            if (isCustomMetadata(key)) {\n              values.split(',').forEach((v) => {\n                result.add(key, Buffer.from(v.trim(), 'base64'));\n              });\n            } else {\n              result.add(key, Buffer.from(values, 'base64'));\n            }\n          }\n        } else {\n          if (Array.isArray(values)) {\n            values.forEach((value) => {\n              result.add(key, value);\n            });\n          } else if (values !== undefined) {\n            result.add(key, values);\n          }\n        }\n      } catch (error) {\n        const message = `Failed to add metadata entry ${key}: ${values}. ${error.message}. For more information see https://github.com/grpc/grpc-node/issues/1173`;\n        log(LogVerbosity.ERROR, message);\n      }\n    });\n    return result;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}