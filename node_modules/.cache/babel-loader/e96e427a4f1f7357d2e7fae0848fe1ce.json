{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BackoffTimeout = void 0;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\n\nfunction uniformRandom(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\nclass BackoffTimeout {\n  constructor(callback, options) {\n    this.callback = callback;\n    /**\n     * The delay time at the start, and after each reset.\n     */\n\n    this.initialDelay = INITIAL_BACKOFF_MS;\n    /**\n     * The exponential backoff multiplier.\n     */\n\n    this.multiplier = BACKOFF_MULTIPLIER;\n    /**\n     * The maximum delay time\n     */\n\n    this.maxDelay = MAX_BACKOFF_MS;\n    /**\n     * The maximum fraction by which the delay time can randomly vary after\n     * applying the multiplier.\n     */\n\n    this.jitter = BACKOFF_JITTER;\n    /**\n     * Indicates whether the timer is currently running.\n     */\n\n    this.running = false;\n    /**\n     * Indicates whether the timer should keep the Node process running if no\n     * other async operation is doing so.\n     */\n\n    this.hasRef = true;\n    /**\n     * The time that the currently running timer was started. Only valid if\n     * running is true.\n     */\n\n    this.startTime = new Date();\n\n    if (options) {\n      if (options.initialDelay) {\n        this.initialDelay = options.initialDelay;\n      }\n\n      if (options.multiplier) {\n        this.multiplier = options.multiplier;\n      }\n\n      if (options.jitter) {\n        this.jitter = options.jitter;\n      }\n\n      if (options.maxDelay) {\n        this.maxDelay = options.maxDelay;\n      }\n    }\n\n    this.nextDelay = this.initialDelay;\n    this.timerId = setTimeout(() => {}, 0);\n    clearTimeout(this.timerId);\n  }\n\n  runTimer(delay) {\n    var _a, _b;\n\n    clearTimeout(this.timerId);\n    this.timerId = setTimeout(() => {\n      this.callback();\n      this.running = false;\n    }, delay);\n\n    if (!this.hasRef) {\n      (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n  }\n  /**\n   * Call the callback after the current amount of delay time\n   */\n\n\n  runOnce() {\n    this.running = true;\n    this.startTime = new Date();\n    this.runTimer(this.nextDelay);\n    const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);\n    const jitterMagnitude = nextBackoff * this.jitter;\n    this.nextDelay = nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);\n  }\n  /**\n   * Stop the timer. The callback will not be called until `runOnce` is called\n   * again.\n   */\n\n\n  stop() {\n    clearTimeout(this.timerId);\n    this.running = false;\n  }\n  /**\n   * Reset the delay time to its initial value. If the timer is still running,\n   * retroactively apply that reset to the current timer.\n   */\n\n\n  reset() {\n    this.nextDelay = this.initialDelay;\n\n    if (this.running) {\n      const now = new Date();\n      const newEndTime = this.startTime;\n      newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);\n      clearTimeout(this.timerId);\n\n      if (now < newEndTime) {\n        this.runTimer(newEndTime.getTime() - now.getTime());\n      } else {\n        this.running = false;\n      }\n    }\n  }\n  /**\n   * Check whether the timer is currently running.\n   */\n\n\n  isRunning() {\n    return this.running;\n  }\n  /**\n   * Set that while the timer is running, it should keep the Node process\n   * running.\n   */\n\n\n  ref() {\n    var _a, _b;\n\n    this.hasRef = true;\n    (_b = (_a = this.timerId).ref) === null || _b === void 0 ? void 0 : _b.call(_a);\n  }\n  /**\n   * Set that while the timer is running, it should not keep the Node process\n   * running.\n   */\n\n\n  unref() {\n    var _a, _b;\n\n    this.hasRef = false;\n    (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n  }\n\n}\n\nexports.BackoffTimeout = BackoffTimeout;","map":{"version":3,"mappings":"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","names":["INITIAL_BACKOFF_MS","BACKOFF_MULTIPLIER","MAX_BACKOFF_MS","BACKOFF_JITTER","uniformRandom","min","max","Math","random","BackoffTimeout","constructor","callback","options","Date","initialDelay","multiplier","jitter","maxDelay","nextDelay","timerId","setTimeout","clearTimeout","runTimer","delay","running","hasRef","unref","_b","runOnce","startTime","nextBackoff","jitterMagnitude","stop","reset","now","newEndTime","setMilliseconds","getMilliseconds","getTime","isRunning","ref","exports"],"sources":["C:\\Users\\binel\\OneDrive\\Desktop\\Today\\Udemy\\iProfiler\\iProfiler\\iprofiler\\node_modules\\@grpc\\grpc-js\\src\\backoff-timeout.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\nfunction uniformRandom(min: number, max: number) {\n  return Math.random() * (max - min) + min;\n}\n\nexport interface BackoffOptions {\n  initialDelay?: number;\n  multiplier?: number;\n  jitter?: number;\n  maxDelay?: number;\n}\n\nexport class BackoffTimeout {\n  /**\n   * The delay time at the start, and after each reset.\n   */\n  private readonly initialDelay: number = INITIAL_BACKOFF_MS;\n  /**\n   * The exponential backoff multiplier.\n   */\n  private readonly multiplier: number = BACKOFF_MULTIPLIER;\n  /**\n   * The maximum delay time\n   */\n  private readonly maxDelay: number = MAX_BACKOFF_MS;\n  /**\n   * The maximum fraction by which the delay time can randomly vary after\n   * applying the multiplier.\n   */\n  private readonly jitter: number = BACKOFF_JITTER;\n  /**\n   * The delay time for the next time the timer runs.\n   */\n  private nextDelay: number;\n  /**\n   * The handle of the underlying timer. If running is false, this value refers\n   * to an object representing a timer that has ended, but it can still be\n   * interacted with without error.\n   */\n  private timerId: NodeJS.Timer;\n  /**\n   * Indicates whether the timer is currently running.\n   */\n  private running = false;\n  /**\n   * Indicates whether the timer should keep the Node process running if no\n   * other async operation is doing so.\n   */\n  private hasRef = true;\n  /**\n   * The time that the currently running timer was started. Only valid if\n   * running is true.\n   */\n  private startTime: Date = new Date();\n\n  constructor(private callback: () => void, options?: BackoffOptions) {\n    if (options) {\n      if (options.initialDelay) {\n        this.initialDelay = options.initialDelay;\n      }\n      if (options.multiplier) {\n        this.multiplier = options.multiplier;\n      }\n      if (options.jitter) {\n        this.jitter = options.jitter;\n      }\n      if (options.maxDelay) {\n        this.maxDelay = options.maxDelay;\n      }\n    }\n    this.nextDelay = this.initialDelay;\n    this.timerId = setTimeout(() => {}, 0);\n    clearTimeout(this.timerId);\n  }\n\n  private runTimer(delay: number) {\n    clearTimeout(this.timerId);\n    this.timerId = setTimeout(() => {\n      this.callback();\n      this.running = false;\n    }, delay);\n    if (!this.hasRef) {\n      this.timerId.unref?.();\n    }\n  }\n\n  /**\n   * Call the callback after the current amount of delay time\n   */\n  runOnce() {\n    this.running = true;\n    this.startTime = new Date();\n    this.runTimer(this.nextDelay);\n    const nextBackoff = Math.min(\n      this.nextDelay * this.multiplier,\n      this.maxDelay\n    );\n    const jitterMagnitude = nextBackoff * this.jitter;\n    this.nextDelay =\n      nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);\n  }\n\n  /**\n   * Stop the timer. The callback will not be called until `runOnce` is called\n   * again.\n   */\n  stop() {\n    clearTimeout(this.timerId);\n    this.running = false;\n  }\n\n  /**\n   * Reset the delay time to its initial value. If the timer is still running,\n   * retroactively apply that reset to the current timer.\n   */\n  reset() {\n    this.nextDelay = this.initialDelay;\n    if (this.running) {\n      const now = new Date();\n      const newEndTime = this.startTime;\n      newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);\n      clearTimeout(this.timerId);\n      if (now < newEndTime) {\n        this.runTimer(newEndTime.getTime() - now.getTime());\n      } else {\n        this.running = false;\n      }\n    }\n  }\n\n  /**\n   * Check whether the timer is currently running.\n   */\n  isRunning() {\n    return this.running;\n  }\n\n  /**\n   * Set that while the timer is running, it should keep the Node process\n   * running.\n   */\n  ref() {\n    this.hasRef = true;\n    this.timerId.ref?.();\n  }\n\n  /**\n   * Set that while the timer is running, it should not keep the Node process\n   * running.\n   */\n  unref() {\n    this.hasRef = false;\n    this.timerId.unref?.();\n  }\n}\n"]},"metadata":{},"sourceType":"script"}